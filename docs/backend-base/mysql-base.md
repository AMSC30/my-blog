# SQL

## 数据模型

关系型数据库

建立在关系型数据模型上，由多张二维表相互连接组成的数据库

sql语句通用语法

- sql语句可以单行或者多行书写，以分号结尾
- sql语句可以使用空格或缩进来增强sql语句的可读性
- sql语句可以不区分大小写，但建议使用大写
- sql语句可以注释，使用#作为单行注释，使用/**/作为多行注释，在mysql中还可以使用#来进行单行注释

## sql语句分类

### DDL语句

数据库定义语言，用于创建和删除数据库、表、字段

#### 数据库操作

- 查询所有数据库: show databases;
- 查询当前使用的数据库：select database();
- 创建数据库：create database [if not exists] 数据库名;
- 删除数据库：drop database [if exists] 数据库名;
- 使用数据库：use 数据库名;

#### 表操作

- 创建表：create table 表名(字段1 字段1类型 [约束] [comment  字段1注释 ],字段2  字段2类型 [约束]  [comment  字段2注释 ],......字段n  字段n类型 [约束]  [comment  字段n注释 ]
) [ comment  表注释 ] ;
- 删除表：drop table [if exists] 表名;
- 修改表名: rename table 表名 to 新表名;
- 查询表结构：desc 表名;
- 查询所有的表: show tables;
- 查询建表语句：show create table 表名;

#### 字段操作

- 添加字段：alter table 表名 add 字段名称 字段类型(长度) [comment 注释]  [约束]
- 修改字段类型：alter table 表名 modify 字段名称 字段类型(长度) [comment 注释]  [约束]
- 修改字段名称和类型：alter table 表名 change 旧名称字段 新名称字段 字段类型(长度) [comment 注释]  [约束]
- 删除字段：alter table 表名 drop column 字段名称;

#### 字段约束

字段约束用于保证表中字段数据的正确性和完整性，是作用于字段的规则

- 非空约束 not null：存储在表中的字段数据不能为null
- 唯一约束 unique：存储在表中的字段数据必须唯一，不能重复
- 主键约束 primary key：存储在表中的字段数据必须唯一且不能重复，并且不能为null
- 默认约束 default：如果没有指定字段的值，则使用默认值
- 外键约束 foreign key：让两张表建立联系

### DML语句

数据库操作语句，用于对数据的增删改

- 添加表指定字段数据：insert into 表名(字段1,字段2,字段3) values（值1,值2,值3)\[,(值1,值2,值3)]
- 添加表所有字段数据：insert into 表名 values(值1,值2,值3,...),(值1,值2,值3,...)
- 修改表指定字段数据：update 表名 set 字段1=值1,字段2=值2,字段3=值3 [where 条件]
- 删除表指定字段数据：delete from 表名 [where 条件]

### DQL语句

#### 基本查询

1. 查询所有字段：select * from 表名
2. 查询多个字段：select 字段1,字段2[,...] from 表名
3. 查询后设置别名 select 字段1 [as] 字段1别名,字段2 from 表名
4. 查询后去除重复值 select distinct 字段列表 from 表名

#### 条件查询

基本语句：select 字段列表 from 表名 where 条件列表

运算符

条件列表中的条件运算符主要分为比较运算符和逻辑运算符

比较运算符：

- \>, >=, \<, \<=, =, !=：做相等和大小判断
- between A and B：在A与B的这个范围之内
- in (...)：值为in后面的列表之一
- like 占位符：模糊匹配，_匹配单个字符；%匹配任意个字符，包括0个；[] 可以匹配集合内的字符,用脱字符 ^ 可以对其进行否定
- is null：值为null，不能使用`=null`
- is not null：值不为null

逻辑运算符：

- and或者&&：逻辑与，同时满足
- or或者||；逻辑或，满足其中一个
- not或者!：逻辑非，不满足条件

#### 分组查询

分组查询语法：select 字段列表 from 表名 [where 条件列表] group by 分组字段名 [having 分组后过滤条件]

示例：select gender,count("date") as "date_count" from user where date <= "2021-12-21" group by date having count("date") > 10

where与having的区别：

- where是在分组之前使用，是对分组前的数据进行过滤，符合条件的才参与分组；having是对分组后的数据进行过滤
- where不能对聚合函数进行判断，having可以

#### 排序查询

排序查询，需要使用order by，支持两种排序方式，asc升序，desc降序，如果不写，默认为asc

基本语法：select 字段列表 from 表名 [where 条件列表] [group by 分组字段名] [having 分组后过滤条件] order by 排序字段1 [asc/desc],排序字段2 [asc/desc]...

#### 分页查询

分页查询中，需要使用limit，数据开始索引从0开始

基本语法为：select 字段列表 from 表名 [where 筛选条件] limit 数据开始索引，单页数量

### DCL语句

数据库控制语言，用于操作数据库的用户及权限

## 数据类型

### 数值型

#### 1. 整数类型

| 类型 | 大小 | 有符号范围 | 无符号范围 | 描述 |
|------|------|------------|------------|------|
| TINYINT | 1byte | (-128，127) | (0，255) | 小整数值 |
| SMALLINT | 2bytes | (-32768，32767) | (0，65535) | 大整数值 |
| MEDIUMINT | 3bytes | (-8388608，8388607) | (0，16777215) | 大整数值 |
| INT/INTEGER | 4bytes | (-2147483648，2147483647) | (0，4294967295) | 大整数值 |
| BIGINT | 8bytes | (-2^63，2^63-1) | (0，2^64-1) | 极大整数值 |

#### 2. 浮点数类型

| 类型 | 大小 | 有符号范围 | 无符号范围 | 描述 |
|------|------|------------|------------|------|
| FLOAT | 4bytes | (-3.402823466 E+38，3.402823466351 E+38) | 0 和 (1.175494351 E-38，3.402823466 E+38) | 单精度浮点数值 |
| DOUBLE | 8bytes | (-1.7976931348623157 E+308，1.7976931348623157 E+308) | 0 和 (2.2250738585072014 E-308，1.7976931348623157 E+308) | 双精度浮点数值 |

#### 3. 精确数值类型

| 类型 | 大小 | 有符号范围 | 无符号范围 | 描述 |
|------|------|------------|------------|------|
| DECIMAL | - | 依赖于M(精度)和D(标度)的值 | 依赖于M(精度)和D(标度)的值 | 小数值(精确定点数) |

修饰符

- unsigned：表示为无符号
- auto_increment：表示自增

### 字符串

| 类型       | 大小                  | 描述                         |
| ---------- | --------------------- | ---------------------------- |
| CHAR       | 0-255 bytes           | 定长字符串(需要指定长度)     |
| VARCHAR    | 0-65535 bytes         | 变长字符串(需要指定长度)     |
| TINYBLOB   | 0-255 bytes           | 不超过255个字符的二进制数据  |
| TINYTEXT   | 0-255 bytes           | 短文本字符串                 |
| BLOB       | 0-65 535 bytes        | 二进制形式的长文本数据       |
| TEXT       | 0-65 535 bytes        | 长文本数据                   |
| MEDIUMBLOB | 0-16 777 215 bytes    | 二进制形式的中等长度文本数据 |
| MEDIUMTEXT | 0-16 777 215 bytes    | 中等长度文本数据             |
| LONGBLOB   | 0-4 294 967 295 bytes | 二进制形式的极大文本数据     |
| LONGTEXT   | 0-4 294 967 295 bytes | 极大文本数据                 |

char 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性能会更高些。

### 日期类型

| 类型      | 大小 | 范围                                       | 格式                | 描述                     |
| --------- | ---- | ------------------------------------------ | ------------------- | ------------------------ |
| DATE      | 3    | 1000-01-01 至  9999-12-31                  | YYYY-MM-DD          | 日期值                   |
| TIME      | 3    | -838:59:59 至  838:59:59                   | HH:MM:SS            | 时间值或持续时间         |
| YEAR      | 1    | 1901 至 2155                               | YYYY                | 年份值                   |
| DATETIME  | 8    | 1000-01-01 00:00:00 至 9999-12-31 23:59:59 | YYYY-MM-DD HH:MM:SS | 混合日期和时间值         |
| TIMESTAMP | 4    | 1970-01-01 00:00:01 至 2038-01-19 03:14:07 | YYYY-MM-DD HH:MM:SS | 混合日期和时间值，时间戳 |

## 多表设计

### 表间关系

1. 一对多

一对多主要通过外键约束来进行实现，外键约束是指一个表中的数据必须与另一个表中的数据一致。

基本语法如下：

- 创建表时添加外键约束：create table 表名称 (字段名称 字段类型 字段约束,... ) CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名称 (主键字段))

- 添加外键约束：alter table 表名称 add constraint 外键名称 foreign key (外键字段) references 主表名称 (主键字段)

物理外键：

使用foreign key指定的外键是物理外键，使用物理外键有个以下几个缺点

- 影响增删改的效率，每次操作都需要检查外键关系
- 不适用于分布式、集群的情况
- 容易引发数据库死锁问题，影响性能

逻辑外键：

在逻辑层中，解决外键关联

2. 一对一

一对一常用于对复杂单表的拆分，将一个单表拆分为多个小的表，

3. 多对多

多对多的实现通过建立第三张表成为中间表，中间表记录两个外键，分别对应另外两张表

### 多表查询

查询多张表中的数据

1. 内连接查询：查询两个表的交集

内连接查询有两种语法，分别是隐式内连接和显式内连接

- 隐式内连接语法：select * from 表1,表2 where 表1.字段=表2.字段;

- 显示内连接语法：select * from 表1 [inner] join 表2 on 表1.字段=表2.字段;

2. 左外连接查询：查询左表所有的数据，包含于右表交集的部分，语法如下：

select * from 表1 left [outer] join 表2 on 表1.字段=表2.字段;

3. 右外连接查询：查询右表所有的数据，包含于左表交集的部分，语法如下：

select * from 表1 right [outer] join 表2 on 表1.字段=表2.字段;

4. 标量子查询：子查询返回的是一个单行单列的值，比如日期、数值、字符串、日期等，语法如下:

select * from 表名 where 字段名 [=|!=|>|>=|<|<=] (select 字段名 from 表名 where 条件);

5. 列子查询：子查询返回的是多行单列的值，子查询的结果常用于条件满足结果值其中一个的情况，语法如下：

select * from 表名 where 字段名 [in|not in] (select 字段名 from 表名 where 条件)

6. 行子查询：子查询返回的结果是一行多列的值，子查询的结果常用于条件满足多个字段结果的情况，语法如下：

select * from 表名 where (字段1,字段2...) [=|!=] (select 字段1,字段2... from 表名 where 条件)

7. 表子查询：子查询返回的结果是一个多行多列的值，子查询的结果常用于作为一张新的表，语法如下：

select e.\* from (select* from 表名 where 条件) as e [inner join|left join|right join] 表名 on e.id=表名.id

### 事务

事务是一系列操作的集合，是数据库操作的一个单位，这些操作要么同时成功，要么同时失败

事务的控制包括开启事务、提交事务、回滚事务

开启事务 start transaction / begin：事务的开头

提交事务 commit：事务提交给数据库软件执行

回滚事务 rollback：当事务失败后取消事务的所有操作

事务的特性：

- 原子性：事务是不可分割的最小单元，要么全部成功，要么全部失败
- 一致性：事务完成后，所有数据必须保持一致性
- 隔离性：事务的执行，是在不受外部并发的影响下在独立的环境中执行
- 持久性：事务一旦完成或者回滚，对数据的改变就是永久的

### 索引

索引是一种帮助高效查询数据的数据结构，但是更新、删除、新增的效率不高，同时索引会占用额外的硬盘空间

创建索引：create [unique] index 索引名称 on 表名(字段名,...)

查询索引：show index from 表名

删除索引：drop index 索引名 on 表名

建表时，如果之定义一个字段为主键，那么数据库会使用这个字段创建`主键索引`，如果指定了字段对应的值为唯一值，那么也会创建对应的`唯一索引`

## 函数

### 聚合函数

分组查询中，经常会用到聚合函数，常见的聚合函数有以下几种：

- count(字段/*)：根据某个字段统计数量
- max(字段)：某个字段为表中最大值的数据
- min(字段)：某个字段为表中最小值的数据
- avg(字段)：计算某个字段的平均值
- sum(字段)：计算某个字段之和

### 文本处理

- LEFT()：左边的字符
- RIGHT()：右边的字符
- LOWER()：转换为小写字符
- UPPER()：转换为大写字符
- LTRIM()：去除左边的空格
- RTRIM()：去除右边的空格
- LENGTH()：长度
- OUNDEX()：转换为语音值

### 日期和时间处理

日期格式为`YYYY-MM-DD`，时间格式为`HH:MM:SS`

- AddDate()：增加一个日期(天、周等)
- AddTime()：增加一个时间(时、分等)
- CurDate()：返回当前日期
- CurTime()：返回当前时间
- Date()：返回日期时间的日期部分
- DateDiff()：计算两个日期之差
- Date_Add()：高度灵活的日期运算函数
- Date_Format()：返回一个格式化的日期或时间串
- Day()：返回一个日期的天数部分
- DayOfWeek()：对于一个日期，返回对应的星期几
- Hour()：返回一个时间的小时部分
- Minute()：返回一个时间的分钟部分
- Month()：返回一个日期的月份部分
- Now()：返回当前日期和时间
- Second()：返回一个时间的秒部分
- Time()：返回一个日期时间的时间部分
- Year()：返回一个日期的年份部分

### 数值处理

- SIN()：正弦
- COS()：余弦
- TAN()：正切
- ABS()：绝对值
- SQRT()：平方根
- MOD()：余数
- EXP()：指数
- PI()：圆周率
- RAND()：随机数

## SQL 的执行过程详解

### MySQL 驱动

MySQL 驱动在底层帮我们做了对数据库的连接，只有建立了连接了，才能够有后面的交互

java 系统在通过 MySQL 驱动和 MySQL 数据库连接的时候是基于 TCP/IP 协议的，所以如果每个请求都是新建连接和销毁连接，多线程请求的时候频繁的创建和销毁连接显然是不合理的，这样势必会造成不必要的浪费和性能的下降

数据库连接池：维护一定的连接数，方便系统获取连接，使用就去池子中获取，用完放回去就可以了。常见的数据库连接池有 Druid、C3P0、DBCP

MySQL 的架构体系中也已经提供了这样的一个池子，也是数据库连池。双方都是通过数据库连接池来管理各个连接的，这样一方面线程之前不需要是争抢连接，更重要的是不需要反复的创建的销毁连接

MySQL语句执行流程如下：

![sql执行流程](./images/db-mysql-sql-8.png)

### 存储引擎

真正执行 SQL 的动作是在存储引擎中完成的。数据是被存放在内存或者是磁盘中的，执行器最终根据一系列的执行计划去调用存储引擎的接口去完成 SQL 的执行

#### 缓冲池

SQL 语句对应的数据要么是在内存中，要么是在磁盘中，如果直接在磁盘中操作，那这样的随机IO读写的速度肯定让人无法接受的，所以每次在执行 SQL 的时候都会将其数据加载到内存中，这块内存就是 InnoDB 中一个非常重要的组件：缓冲池 `Buffer Pool`

Buffer Pool （缓冲池）是 InnoDB 存储引擎中非常重要的内存结构，顾名思义，缓冲池其实就是类似 Redis 一样的作用，起到一个缓存的作用，因为我们都知道 MySQL 的数据最终是存储在磁盘中的，如果没有这个 Buffer Pool 那么我们每次的数据库请求都会磁盘中查找，这样必然会存在 IO 操作，这肯定是无法接受的。但是有了 Buffer Pool 就是我们第一次在查询的时候会将查询的结果存到 Buffer Pool 中，这样后面再有请求的时候就会先从缓冲池中去查询，如果没有再去磁盘中查找，然后在放到 Buffer Pool 中

有了缓冲池，存储引擎的执行顺序：

1. InnoDB存储引擎会在缓冲池中查找 id=1 的这条数据是否存在
2. 发现不存在，那么就会去磁盘中加载，并将其存放在缓冲池中
3. 该条记录会被加上一个独占锁

#### undo日志

Innodb 存储引擎的最大特点就是支持事务，如果本次更新失败，也就是事务提交失败，那么该事务中的所有的操作都必须回滚到执行前的样子，也就是说当事务失败的时候，也不会对原始数据有影响

在准备更新一条语句的时候，该条语句已经被加载到 Buffer pool 中了，实际上这里还有这样的操作，就是在将该条语句加载到 Buffer Pool 中的时候同时会往 undo 日志文件中插入一条日志，也就是将 id=1 的这条记录的原来的值记录下来

#### redo日志

redo日志(重做日志)是 InnoDB 特有的，他是存储引擎级别的，不是 MySQL 级别的

MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中

后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能

更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新

然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里

存储引擎流程图如下：

![存储引擎流程图](./images/db-mysql-sql-12.png)

#### bin日志

binlog 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层

不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志

binlog 会记录所有涉及更新数据的逻辑操作，并且是顺序写，可以用来同步数据，保证数据一致性

binlog 日志有三种格式，可以通过binlog_format参数指定

1. STATEMENT

默认值，记录每条语句的完整内容，同步数据时，会执行记录的SQL语句，但是有个问题，update_time=now()这里会获取当前系统时间，直接执行会导致与原库的数据不一致

2. row

记录的内容不再是简单的SQL语句了，还包含操作的具体数据

3. mixed

记录的内容是前两者的混合，MySQL 会判断这条SQL语句是否可能引起数据不一致，如果是，就用row格式，否则就用statement格式
