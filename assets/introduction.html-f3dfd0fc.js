import{_ as a,p as i,q as e,Y as l}from"./framework-e1bed10d.js";const h="/my-blog/assets/system-cf8668a2.png",r={},d=l('<h1 id="前端项目架构" tabindex="-1"><a class="header-anchor" href="#前端项目架构" aria-hidden="true">#</a> 前端项目架构</h1><p>先上一张图：</p><img src="'+h+'"><h2 id="综述" tabindex="-1"><a class="header-anchor" href="#综述" aria-hidden="true">#</a> 综述</h2><p>前端架构的设计，应是用于解决已存在或者未来可能发生的技术问题，增加项目的可管理性、稳定性、可扩展性</p><p>架构里设计的内容，一定要有是可衡量的意义的，最好是可以定量的——即可以衡量带来的收益或减少的成本，至少是可以定性的——即虽然无法用数字阐述收益，但我们可以明确这个是有意义的，例如增加安全性降低风险</p><h2 id="基础层设计" tabindex="-1"><a class="header-anchor" href="#基础层设计" aria-hidden="true">#</a> 基础层设计</h2><h3 id="自建gitlab" tabindex="-1"><a class="header-anchor" href="#自建gitlab" aria-hidden="true">#</a> 自建Gitlab</h3><p>公司代码是公司的重要资产，使用自建Gitlab可以有效保护公司资产，使用gitlab作为项目文档和代码的仓库管理，为项目的可控性提供有效保障</p><h3 id="自动编译发布" tabindex="-1"><a class="header-anchor" href="#自动编译发布" aria-hidden="true">#</a> 自动编译发布</h3><p>执行一系列流程，例如自动编译打包合并，然后再从Gitlab发布到CDN或者静态资源服务器。如：Jenkins</p><p>让研发人员专心于研发，和环境、运维等事情脱钩</p><h3 id="埋点系统" tabindex="-1"><a class="header-anchor" href="#埋点系统" aria-hidden="true">#</a> 埋点系统</h3><p>埋点系统是前端高度介入业务，把握业务发展情况的一把利剑，通过这个系统，我们可以比后端更深刻的把握用户的习惯，以及给产品经理、运营等人员提供准确的数据依据。当有了数据后，前端人员就可以针对性的优化功能、布局、页面交互逻辑、用户使用流程。 埋点系统应和业务解耦，开发人员使用时注册，然后在项目中引入。然后在埋点系统里查看相关数据（例如以小时、日、周、月、年为周期查看）</p><p>前端埋点系统的好处：</p><ul><li>记录每个页面的访问量（日周月年的UV、PV）；</li><li>记录每个功能的使用量；</li><li>捕捉报错情况；</li><li>图表化显示，方便给其他部门展示；</li></ul><h3 id="监控和报警系统" tabindex="-1"><a class="header-anchor" href="#监控和报警系统" aria-hidden="true">#</a> 监控和报警系统</h3><p>监控和报警系统应基于埋点系统而建立，在以下场景时触发：</p><ul><li>当访问量有比较大的变化（比如日PV/UV只有之前20%以下）时，自动触发报警，发送邮件到相关人员邮箱；</li><li>比如报错量大幅度上升（比如200%或更高），则触发报警；</li><li>当一段时间内没有任何访问量（不符合之前的情况），则触发报警；</li><li>每过一段时间，自动汇总访问者/报错触发者的相关信息（例如系统、浏览器版本等）；</li></ul><p>建设这个系统的好处在于，提前发现一些不容易发现的bug（需要埋点做的比较扎实）。有一些线上bug，因为用户环境特殊，导致无法被开发人员和测试人员发现。但其中一部分bug又因为不涉及资金，并不会导致资损（因此也不会被后端的监控系统所发现），这样的bug非常容易影响项目里某个链路的正常使用。</p><h3 id="代码规范控制" tabindex="-1"><a class="header-anchor" href="#代码规范控制" aria-hidden="true">#</a> 代码规范控制</h3><p>代码规范控制的好处很多：</p><ul><li>降低低级bug（例如拼写问题）出现的概率；</li><li>增加代码的可维护性，可阅读性；</li><li>硬性统一代码风格，团队协作起来时更轻松；</li></ul><p>强烈推荐使用Eslint、Prettier、styleLint等工具结合的方式，对我们提高代码的可维护性的帮助会很大。</p><p>可以考虑在上传到代码仓库时，硬性要求eslint校验，通过的才允许上传。</p><h3 id="代码提交规范控制" tabindex="-1"><a class="header-anchor" href="#代码提交规范控制" aria-hidden="true">#</a> 代码提交规范控制</h3><p>代码提交信息是描述代码改动的重要线索，清晰统一的提交信息，有助于快速搜索到修改内容</p><h3 id="mock" tabindex="-1"><a class="header-anchor" href="#mock" aria-hidden="true">#</a> Mock</h3><p>Mock也是常见前端系统之一，用于解决在后端接口未好时，生成返回的数据</p><h2 id="应用层设计" tabindex="-1"><a class="header-anchor" href="#应用层设计" aria-hidden="true">#</a> 应用层设计</h2><h3 id="多页和单页" tabindex="-1"><a class="header-anchor" href="#多页和单页" aria-hidden="true">#</a> 多页和单页</h3><p>除了特殊场景，通常推荐使用多页架构。理由如下：</p><ul><li>因此当一个页面需要单独重构时，不会影响其他页面，对于有长期历史的项目来说，可维护性、可重构性要高很多；</li><li>缺点是不同页面切换时，会有一个白屏时间，但通常来说，这个时间并不长，大部分现有大公司的线上网页，都是这样的，因此认为是可以接受的；</li><li>可以单次只更新一个页面的版本，而单页项目如果其中一个功能模块要更新（特别是公共组件更新），很容易让所有页面都需要更新版本；</li><li>版本控制更简单，如果需要页面拆分，调整部分页面的使用流程，难度也会更低；</li><li>灰度发布更友好</li></ul><h3 id="前端库选择" tabindex="-1"><a class="header-anchor" href="#前端库选择" aria-hidden="true">#</a> 前端库选择</h3><p>目前使用较多的是Vue、React、Angular三个库，并有与之对应的全家桶（路由管理、状态管理），根据项目成员技术栈和项目实际情况选择合适的渲染库即可</p><h3 id="ui组件库选择" tabindex="-1"><a class="header-anchor" href="#ui组件库选择" aria-hidden="true">#</a> UI组件库选择</h3><p>对于组件库的建设，不建议研发人员较少时去做这件事情</p><p>建议使用比较靠谱的第三方UI库，这样性价比更高。</p><p>设计基础组件库的前提，是要求统一技术栈，这样才能最大化基础组件库的效益。组件库建议以使用以下参考标准：</p><ul><li>使用ts；</li><li>可扩展性强；</li><li>适用程度高；</li><li>文档清楚详细；</li><li>版本隔离，小版本优化加功能，大改需要大版本更新；</li><li>和UI协调统一，要求UI交互参与进来；</li></ul><h3 id="图标库选择" tabindex="-1"><a class="header-anchor" href="#图标库选择" aria-hidden="true">#</a> 图标库选择</h3><p>系统中图标是必不可少的要素，选择轻量易扩展的图标尤其重要</p><h3 id="浏览器兼容" tabindex="-1"><a class="header-anchor" href="#浏览器兼容" aria-hidden="true">#</a> 浏览器兼容</h3><p>常见的问题是IE6、7、8，以及部分小众浏览器（PC和手机）产生的奇怪问题。因此应该考虑统一解决方案，避免bug的重复产生。常见解决方案有：</p><ul><li>配置postcss，让某些css增加兼容性前缀；</li><li>写一个webpack的loader，处理某些特殊场景；</li><li>规范团队代码，使用更稳定的写法（例如移动端避免使用fixed进行布局）；</li><li>对常见问题、疑难问题，总结解决方案并团队共享；</li><li>建议或引导用户使用高版本浏览器（比如chrome）；</li></ul>',45),t=[d];function n(s,c){return i(),e("div",null,t)}const o=a(r,[["render",n],["__file","introduction.html.vue"]]);export{o as default};
