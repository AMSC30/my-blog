import{_ as n,p as a,q as s,Y as e}from"./framework-e1bed10d.js";const t="/my-blog/assets/thread-status-3f95b453.png",p="/my-blog/assets/collection-47ff819a.png",l="/my-blog/assets/map-871e659a.png",i={},c=e(`<h1 id="java语法基础" tabindex="-1"><a class="header-anchor" href="#java语法基础" aria-hidden="true">#</a> Java语法基础</h1><h2 id="常用到的dos命令" tabindex="-1"><a class="header-anchor" href="#常用到的dos命令" aria-hidden="true">#</a> 常用到的DOS命令</h2><h3 id="切换盘符" tabindex="-1"><a class="header-anchor" href="#切换盘符" aria-hidden="true">#</a> 切换盘符</h3><p>盘符名+:+回车</p><blockquote><p>示例：D:+回车</p></blockquote><h3 id="查看文件或者文件夹" tabindex="-1"><a class="header-anchor" href="#查看文件或者文件夹" aria-hidden="true">#</a> 查看文件或者文件夹</h3><ol><li>查看当前路径下的文件或者文件夹</li></ol><p>使用dir命令</p><blockquote><p>示例：dir</p></blockquote><ol start="2"><li>查看指定路径下的文件或者文件夹</li></ol><p>使用dir命令 + 路径</p><blockquote><p>示例：dir D:\\Java</p></blockquote><ol start="3"><li>查看指定路径下的文件或者文件夹的详细信息</li></ol><p>使用dir命令 + /s + 路径</p><blockquote><p>示例：dir /s D:\\Java</p></blockquote><h3 id="进入指定文件夹" tabindex="-1"><a class="header-anchor" href="#进入指定文件夹" aria-hidden="true">#</a> 进入指定文件夹</h3><ol><li>使用cd命令</li></ol><blockquote><p>示例：cd D:\\Java</p></blockquote><ol start="2"><li>使用cd命令 + .. 进入上一级目录</li></ol><blockquote><p>示例：cd ..</p></blockquote><h3 id="文件夹操作" tabindex="-1"><a class="header-anchor" href="#文件夹操作" aria-hidden="true">#</a> 文件夹操作</h3><ol><li>在当前目录下创建文件夹</li></ol><p>使用mkdir命令</p><blockquote><p>示例：mkdir Java</p></blockquote><ol start="2"><li>在当前目录下创建多级文件夹</li></ol><p>使用mkdir + 路径</p><blockquote><p>示例：mkdir \\Java\\learn</p></blockquote><ol start="3"><li>删除文件夹</li></ol><p>使用rmdir + /s + 路径</p><blockquote><p>示例：rmdir /s D:\\Java</p></blockquote><ol start="4"><li>删除文件夹下的所有文件</li></ol><p>使用del + /q + 路径，删除之后不走回收站</p><blockquote><p>示例：del /q D:\\Java</p></blockquote><ol start="5"><li>删除文件夹下的所有文件及子文件夹</li></ol><p>使用rd + /s + /q + 路径，删除之后不走回收站</p><blockquote><p>示例：rd /s /q D:\\Java</p></blockquote><ol start="6"><li>重命名文件夹</li></ol><p>使用ren + 旧文件夹名 + 新文件夹名</p><blockquote><p>示例：ren D:\\Java D:\\Java_learn</p></blockquote><ol start="7"><li>移动文件夹</li></ol><p>使用move + 源文件夹 + 目标文件夹</p><blockquote><p>示例：move D:\\Java D:\\Java_learn</p></blockquote><h2 id="常量" tabindex="-1"><a class="header-anchor" href="#常量" aria-hidden="true">#</a> 常量</h2><p>程序运行中，值不会发生改变的数据</p><h3 id="整数常量" tabindex="-1"><a class="header-anchor" href="#整数常量" aria-hidden="true">#</a> 整数常量</h3><p>所有的整数</p><h3 id="小数常量" tabindex="-1"><a class="header-anchor" href="#小数常量" aria-hidden="true">#</a> 小数常量</h3><p>所有带小数点的数字，如1.2，2.0</p><h3 id="字符常量" tabindex="-1"><a class="header-anchor" href="#字符常量" aria-hidden="true">#</a> 字符常量</h3><p>使用单引号括号包裹的字符，内容必须有且为一个字符，如 &#39;a&#39;、&#39; &#39;</p><blockquote><p>注意：不能使用&#39;&#39;的形式</p></blockquote><h3 id="字符串常量" tabindex="-1"><a class="header-anchor" href="#字符串常量" aria-hidden="true">#</a> 字符串常量</h3><p>使用双引号包裹的若干字符，内容可以是任何形式</p><h3 id="布尔常量" tabindex="-1"><a class="header-anchor" href="#布尔常量" aria-hidden="true">#</a> 布尔常量</h3><p>只有两个值，true和false</p><h3 id="空常量" tabindex="-1"><a class="header-anchor" href="#空常量" aria-hidden="true">#</a> 空常量</h3><p>表示数据不存在，只有一个值null</p><h2 id="变量" tabindex="-1"><a class="header-anchor" href="#变量" aria-hidden="true">#</a> 变量</h2><h3 id="变量的数据类型" tabindex="-1"><a class="header-anchor" href="#变量的数据类型" aria-hidden="true">#</a> 变量的数据类型</h3><h4 id="基本数据类型" tabindex="-1"><a class="header-anchor" href="#基本数据类型" aria-hidden="true">#</a> 基本数据类型</h4><p>基本数据类型分为四类八种</p><ol><li>整型：</li></ol><p>byte：字节型，占用一个字节，基本不用</p><p>short：短整型，占用两个字节</p><p>int：整型，数字的默认类型，占用4个字节</p><p>long：长整型，占用8个字节</p><ol start="2"><li>浮点型：</li></ol><p>float：单精度浮点型，占用4个字节</p><p>double：双精度浮点型，占用8个字节，是浮点型的默认类型</p><blockquote><p>float与double的区别 float:小数位只有23位二进制，能表示的最大的十进制位2的23次方，即8388608，是七位数 double:小数位只有52位二进制，能表示的最大的十进制位2的52次方，即4503599627370496，是16位</p></blockquote><ol start="3"><li>布尔型：</li></ol><p>boolean：布尔型，只有两个值true和false，占用1个字节</p><ol start="4"><li>字符型：</li></ol><p>char：占用2个字节</p><h4 id="引用数据类型" tabindex="-1"><a class="header-anchor" href="#引用数据类型" aria-hidden="true">#</a> 引用数据类型</h4><p>类、数组、接口、枚举、注解</p><h4 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h4><p>定义一个数组</p><p>数组是一个固定长度的容器，既可以存储基本数据类型也可以存储引用数据类型，数组存储的数据类型必须一致</p><p>动态声明数组：通过指定数组长度而不对数组进行初始化来声明一个数组，例如：int[] a = new int[10];</p><p>静态声明数组：通过指定数组内容来声明一个数组，例如：int[] a = {1,2,3,4,5};</p><p>数组操作：</p><ol><li><p>获取数组长度：a.length</p></li><li><p>获取数组元素：a[i]</p></li><li><p>赋值：a[i] = 1</p></li><li><p>创建静态数组：int[] a = {1,2,3,4,5};</p></li><li><p>创建动态数组：int[] a = new int[10];</p></li></ol><h3 id="变量使用注意事项" tabindex="-1"><a class="header-anchor" href="#变量使用注意事项" aria-hidden="true">#</a> 变量使用注意事项</h3><ol><li><p>变量未声明或未赋值不能直接使用</p></li><li><p>同一作用域不能重复声明变量</p></li><li><p>静态变量和实例变量不能有相同的名称</p></li><li><p>变量声明不能使用数字开头，变量名可以包含字母、数字、下划线_、$符号</p></li></ol><h3 id="数据类型转换" tabindex="-1"><a class="header-anchor" href="#数据类型转换" aria-hidden="true">#</a> 数据类型转换</h3><p>当等号两边的数据类型不一致时，数据类型转换；当不同的数据类型进行运算时，数据类型转换</p><h4 id="自动类型转换" tabindex="-1"><a class="header-anchor" href="#自动类型转换" aria-hidden="true">#</a> 自动类型转换</h4><ol><li><p>当取值范围小的数据类型赋值到取值范围大的数据类型时，数据类型小转大</p></li><li><p>当取值范围小的数据类型与取值范围大的数据类型进行运算时，数据类型小转大</p></li></ol><h4 id="强制类型转换" tabindex="-1"><a class="header-anchor" href="#强制类型转换" aria-hidden="true">#</a> 强制类型转换</h4><p>当取值范围的大的数据类型赋值给取值范围小的数据类型时，数据类型大转小</p><h4 id="数据转换的注意事项" tabindex="-1"><a class="header-anchor" href="#数据转换的注意事项" aria-hidden="true">#</a> 数据转换的注意事项</h4><ol><li><p>不应随意转换数据类型，会有精度丢失或者数据溢出的情况</p></li><li><p>byte，short类型定义时，如果等号右边是整数字面量且没有超出范围，不需要手动转换</p></li><li><p>char类型如果参与运算，会提升为int型，值为ASCII码，如果码表中没有，则在unicode码表中找</p></li></ol><h4 id="数据类型取值范围比较" tabindex="-1"><a class="header-anchor" href="#数据类型取值范围比较" aria-hidden="true">#</a> 数据类型取值范围比较</h4><p>byte &lt; short,char &lt; int &lt; long &lt; float &lt; double</p><h3 id="内存图" tabindex="-1"><a class="header-anchor" href="#内存图" aria-hidden="true">#</a> 内存图</h3><p>在java程序中，内存分为5大块</p><h4 id="栈内存" tabindex="-1"><a class="header-anchor" href="#栈内存" aria-hidden="true">#</a> 栈内存</h4><p>存放基本数据类型，对象引用，方法参数，局部变量，方法的运行也在栈内存中进行</p><h4 id="堆内存" tabindex="-1"><a class="header-anchor" href="#堆内存" aria-hidden="true">#</a> 堆内存</h4><p>存放引用类型的数据，每个数据在堆内存中开辟一个空间，并在栈内存中保存这块空间的地址，堆内存是动态分配的，并且堆内存的数据都是有默认值的，比如int型变量，默认值为0；</p><h4 id="方法区" tabindex="-1"><a class="header-anchor" href="#方法区" aria-hidden="true">#</a> 方法区</h4><p>方法区存放类和方法的信息，class文件也是被加载到方法区中，方法区是静态分配的，方法区中的数据没有默认值</p><h4 id="本地方法栈" tabindex="-1"><a class="header-anchor" href="#本地方法栈" aria-hidden="true">#</a> 本地方法栈</h4><p>专门运行本地方法</p><h4 id="寄存器" tabindex="-1"><a class="header-anchor" href="#寄存器" aria-hidden="true">#</a> 寄存器</h4><p>待补充</p><h2 id="面向对象" tabindex="-1"><a class="header-anchor" href="#面向对象" aria-hidden="true">#</a> 面向对象</h2><h3 id="类" tabindex="-1"><a class="header-anchor" href="#类" aria-hidden="true">#</a> 类</h3><p>类是对一类事物的抽象表示，由属性(成员变量)和行为(成员方法)组成</p><p>测试类：带main方法的类，主要用于运行代码</p><p>实体类：无main方法的类，主要用来表示对象</p><p>抽象类：抽象类不能实例化，只能被继承，抽象类中可以有抽象方法，抽象方法没有方法体，抽象方法必须被继承类实现</p><p>抽象类和实体类区别：抽象类不能实例化，只能被继承</p><h3 id="抽象" tabindex="-1"><a class="header-anchor" href="#抽象" aria-hidden="true">#</a> 抽象</h3><p>抽象是指不具体实现，抽象方法不能有方法体并且一定要在抽象类中，抽象类中可以有抽象方法，也可以没有抽象方法</p><p>抽象类不能实例化，只能被继承；非抽象子类的继承必须重写父类的所有抽象方法</p><p>抽象类可以看做是一个事物的标准模板，属于这个父类的子类，所有抽象方法都必须得到具体实现</p><p>定义一个抽象类：abstract class 类名{}</p><p>定义抽象方法：abstract 返回值类型 方法名(参数列表);</p><h3 id="封装" tabindex="-1"><a class="header-anchor" href="#封装" aria-hidden="true">#</a> 封装</h3><p>将实现的细节封装起来，对外提供接口</p><p>使用private修饰的成员变量，外部类不能直接访问，只能通过getter和setter方法访问</p><p>如果成员变量和成员变量重名时，优先访问局部变量，也就是就近原则，使用this关键字可以访问成员变量，this代表调用this所在方法的对象</p><p>构造方法：构造方法名与类型相同，没有返回值，并且不适用void，分为有参构造和无参构造</p><p>定义一个类时，jvm内部默认会有一个无参构造方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>&#39;我是无参构造方法&#39;<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有参构造方法可以在new的时候为对象的成员变量进行赋值，当定义了一个有参构造方法后，jvm提供的默认无参构造方法会被覆盖，我们可以自己定义一个无参构造方法，此时实例化对象时既可以传参也可以不传参</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>&#39;我是无参构造方法&#39;<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="javabean" tabindex="-1"><a class="header-anchor" href="#javabean" aria-hidden="true">#</a> javabean</h4><p>javabean是一种编码规范，类必须是具体的和公共的，不能是抽象类；类中包含无参构造和有参构造方法；成员的变量私有化，提供getter和setter方法</p><h4 id="static" tabindex="-1"><a class="header-anchor" href="#static" aria-hidden="true">#</a> static</h4><p>静态关键字，用于修饰成员变量和成员方法，通过static修饰的变量和方法属于类的属性和方法，加载时随着类的加载而加载</p><p>使用包含静态成员的类创建出来的所有对象共享静态成员</p><p>静态成员访问特点：</p><ol><li><p>静态成员访问非静态成员：需要通过new创建对象后调用</p></li><li><p>静态成员访问静态成员：本类可以直接访问，也可以通过类名访问，他类需要通过类名访问</p></li><li><p>非静态成员访问非静态成员：本类可以直接访问，他类需要通过new创建对象访问</p></li><li><p>非静态成员访问静态成员：本类可以直接访问，他类需要通过类名访问</p></li></ol><h4 id="final关键字" tabindex="-1"><a class="header-anchor" href="#final关键字" aria-hidden="true">#</a> final关键字</h4><p>final修饰符用于修饰类，类中的成员变量、成员方法、局部变量和对象</p><ol><li>修饰类</li></ol><p>使用final修饰符修饰类时，类不能被继承，类中的成员不能被重写</p><ol start="2"><li>修饰方法</li></ol><p>使用final修饰符修饰父类方法时，子类继承父类不能重写父类被final修饰的方式；final修饰符不能修饰构造方法和静态方法，并且不能与abstract同时使用</p><ol start="3"><li>修饰成员变量</li></ol><p>成员变量在定义类的时候需要手动赋值，包括在构造函数中也不能对其赋值</p><ol start="4"><li>修饰局部变量</li></ol><p>使用final修饰符修饰局部变量时，不能对局部变量进行赋值，如果局部变量是引用类型，可以修改引用类型中的值</p><h4 id="访问修饰符" tabindex="-1"><a class="header-anchor" href="#访问修饰符" aria-hidden="true">#</a> 访问修饰符</h4><p>权限修饰符用于修饰类和类中的成员，只有default和public可以用于修饰类，不使用任何修饰符时，表示default(友好型)</p><ol><li>public：如果一个类或者类的成员被public访问控制符修饰，那么这个类或者类的成员能被所有的类访问，不管访问类与被访问类是否在同一个包中</li><li>protected：如果一个类的成员被protected访问控制符修饰，那么这个成员既能被同一包下的其他类访问，也能被不同包下该类的子类访问</li><li>default：如果一个类或者类的成员不使用任何访问控制符修饰，则称它为默认访问控制级别，这个类或者类的成员只能被本包中的其他类访问</li><li>private：如果类的成员被private访问控制符来修饰，则这个成员只能被该类的其他成员访问，其他类无法直接访问。类的良好封装就是通过private关键字来实现的；使用private 修饰的方法不能被子类重写</li></ol><p>表格总结：</p><table><thead><tr><th>形式</th><th style="text-align:center;">public</th><th style="text-align:right;">protected</th><th style="text-align:center;">default</th><th style="text-align:right;">private</th></tr></thead><tbody><tr><td>同包同类</td><td style="text-align:center;">yes</td><td style="text-align:right;">yes</td><td style="text-align:center;">yes</td><td style="text-align:right;">yes</td></tr><tr><td>同包不同类</td><td style="text-align:center;">yes</td><td style="text-align:right;">yes</td><td style="text-align:center;">yes</td><td style="text-align:right;">no</td></tr><tr><td>不同包继承</td><td style="text-align:center;">yes</td><td style="text-align:right;">yes</td><td style="text-align:center;">no</td><td style="text-align:right;">no</td></tr><tr><td>不同包非继承</td><td style="text-align:center;">yes</td><td style="text-align:right;">no</td><td style="text-align:center;">no</td><td style="text-align:right;">no</td></tr></tbody></table><h3 id="继承" tabindex="-1"><a class="header-anchor" href="#继承" aria-hidden="true">#</a> 继承</h3><p>继承是子类可以继承父类中的属性和方法，是java中实现复用的重要手段，在java中继承是单一的，即一个子类只能有一个父类，但是一个父类可以有多个子类</p><p>继承通过extends实现一个子类继承一个父类，子类有自己的构造方法，可以继承父类的私有和非私有成员，但是不能继承父类的构造方法，也不能使用父类中的私有成员</p><p>java中所有的类都继承自Object类，所以除了Object类，所有的类都有一个父类</p><h4 id="成员变量访问" tabindex="-1"><a class="header-anchor" href="#成员变量访问" aria-hidden="true">#</a> 成员变量访问</h4><p>当子类和父类有相同的成员变量时，子类会覆盖父类成员变量，此时使用子类对象访问成员变量时，会优先使用子类成员变量，如果使用父类对象访问成员变量，则优先使用父类成员变量</p><p>当子类和父类的成员变量不重名时，如果等号左边是父类类型，只能调用父类中的成员变量；如果等号左边是子类类型，优先调用子类成员变量，子类没有，再调用父类的非私有成员变量</p><h4 id="成员方法访问" tabindex="-1"><a class="header-anchor" href="#成员方法访问" aria-hidden="true">#</a> 成员方法访问</h4><p>在继承中，访问成员方法，看使用new时使用的哪个类，就优先调用哪个类的成员方法</p><p>如果是父类，则只能调用父类中的成员方法；如果是子类，则优先调用子类中的成员方法，子类没有，再调用父类的非私有成员方法</p><blockquote><p>总结：访问方法和变量，都是子类可以访问父类非私有，父类不能访问子类;变量通过=左边确定类型，方法通过new确定类型</p></blockquote><h4 id="方法重写" tabindex="-1"><a class="header-anchor" href="#方法重写" aria-hidden="true">#</a> 方法重写</h4><p>在继承关系中，当父类和子类拥有相同的方法名和参数列表时，此时父类的方法被子类重写，方法的调用符合继承中成员方法的访问特点</p><ul><li>子类重写父类方法后，访问权限必须大于等于父类</li><li>父类中的构造方法、私有方法(private)、静态方法(static)不能被重写</li><li>子类方法抛出的异常应该是父类方法抛出异常的子类类型</li></ul><h4 id="super" tabindex="-1"><a class="header-anchor" href="#super" aria-hidden="true">#</a> Super</h4><p>Super代表父类的引用，可以调用父类中的成员</p><ol><li>调用父类构造函数：在子类的构造函数中第一行调用Super()或者Super(参数)</li><li>调用父类的成员变量：在子类中成员方法中使用Super.a</li><li>调用父类的成员方法：在子类中成员方法中使用Super.a()</li></ol><h4 id="this" tabindex="-1"><a class="header-anchor" href="#this" aria-hidden="true">#</a> this</h4><p>表示调用this所在方法的调用对象</p><ol><li>用与区分成员变量和局部变量</li><li>调用对象的成员</li></ol><p>除了指向对象，this还可以单独调用，即this()，这种使用方式可以调用当前对象的构造方法</p><h3 id="接口" tabindex="-1"><a class="header-anchor" href="#接口" aria-hidden="true">#</a> 接口</h3><p>接口是一种抽象的类型，不能实例化对象，只能通过implements关键字实现，一个类可以继承一个或多个接口；一个接口可以继承一个或多个接口</p><p>定义接口：public interface 接口名{}</p><p>实现接口:public class 类名 implements 接口名{}</p><p>接口中的成员变量默认是public static final的，如果不加public static，编译器会自动为我们加上，所以在接口中，只能使用静态变量，并且必须初始化，按照规范，变量名最好使用大写。接口中的成员方法默认是public abstract的，如果不加public abstract，编译器会自动加上</p><blockquote><p>jdk8以后新增了默认方法和静态方法，jdk9以后新增了私有方法</p></blockquote><p>一个类实现的多个接口有相同名称和参数的抽象方法，实现类需要且只需要重写一次；</p><p>一个类实现的多个接口有相同名称和参数的默认方法，实现类需要且必须重写该方法</p><h4 id="抽象类与接口" tabindex="-1"><a class="header-anchor" href="#抽象类与接口" aria-hidden="true">#</a> 抽象类与接口</h4><p>接口是抽象的，抽象类是具体的，抽象类可以有抽象方法，抽象类也可以有具体方法</p><p>一个接口可以继承多个接口，如public interface 接口名 extends 接口名1,接口名2{}</p><p>一个实现类可以实现多个接口，如public class 类名 implements 接口名1,接口名2{}</p><p>当多个接口有相同的抽象方法且参数相同时，实现类只需要重写一次即可</p><p>当多个接口有相同的默认方法且参数相同时，实现类必须重写一次默认方法</p><h3 id="多态" tabindex="-1"><a class="header-anchor" href="#多态" aria-hidden="true">#</a> 多态</h3><p>多态是指在面向对象编程中，同一个类的对象在不同情况下表现出来的不同行为和状态。 多态的目的是为了提高代码的灵活性和可扩展性，使得代码更容易维护和扩展。</p><p>多态的前提：</p><ol><li>必须和一个类有继承关系或者和一个接口有实现关系</li><li>必须有方法的重写，多态的意义主要就是方法的重写</li><li>必须有父类引用指向子类对象</li></ol><p>多态的实现：父类可以接收子类对象</p><h4 id="转型" tabindex="-1"><a class="header-anchor" href="#转型" aria-hidden="true">#</a> 转型</h4><p>多态中的父类引用变量指向子类对象，这种方式是一种向上转型，只能使用父类已声明的方法，但方法如果被重写会执行子类的方法，如果方法未被重写那么将执行父类的方法,例如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token class-name">Animal</span> animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>向下转型是指，将父类对象转为子类类型，在书写上父类对象需要加括号()强制转换为子类类型。但父类引用变量实际引用必须是子类对象才能成功转型，就可以调用一些子类特有而父类没有的方法 例如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token class-name">Animal</span> animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Dog</span> dog <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">)</span> animal<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>转型过程中，可能会转成错误类型，这时会抛出ClassCastException异常，通过instanceof关键字判断对象类型，然后再进行转型。</p><h2 id="内部类" tabindex="-1"><a class="header-anchor" href="#内部类" aria-hidden="true">#</a> 内部类</h2><p>当一个类中，对事物的描述过于复杂时，可以使用内部类，内部类是对事物一部分的描述，内部氛围成员内部类、静态内部类、局部内部类</p><h3 id="成员内部类" tabindex="-1"><a class="header-anchor" href="#成员内部类" aria-hidden="true">#</a> 成员内部类</h3><p>在类的内部定义，不使用static修饰</p><p>定义方式：一般不可以定义静态成员，除非同时使用static和final进行修饰</p><p>访问权限：成员内部类可以访问外部类的所有成员变量和方法</p><p>被访问权限：在实例方法中访问，可以直接使用new Inner()的方式，外部类的静态方法和外部类的外部，需要使用new Outer().new Inner()</p><h3 id="静态内部类" tabindex="-1"><a class="header-anchor" href="#静态内部类" aria-hidden="true">#</a> 静态内部类</h3><p>在类的内部定义，使用static修饰</p><p>访问权限：可以直接访问外部类的静态变量和静态方法，要访问外部类的实例变量和实例方式需要使用new Outer()的方式</p><p>被访问权限：外部类的静态变量和静态方法以及外部类以外的类，需要通过完整的路径访问，即Outer.Inner.method()</p><h3 id="局部内部类" tabindex="-1"><a class="header-anchor" href="#局部内部类" aria-hidden="true">#</a> 局部内部类</h3><p>在方法的内部定义，不能定义静态成员，不能定义静态方法，不能使用static进行修饰</p><h2 id="异常" tabindex="-1"><a class="header-anchor" href="#异常" aria-hidden="true">#</a> 异常</h2><p>代码的编写出现非正常现象，称为异常，异常分为编译时异常和运行时异常，编译时异常必须处理，运行时异常可以不处理，但是建议处理 异常都是一个一个的类型，继承自Throwable类，除了RuntimeException及其子类，其他都是编译时异常</p><p>异常处理常用的两种方式：try-catch和throws</p><h3 id="try-catch" tabindex="-1"><a class="header-anchor" href="#try-catch" aria-hidden="true">#</a> try-catch</h3><p>try-catch使用代码块包括语句，可以使用多个catch处理不同的异常类型，的语法格式如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 代码块1</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>exceptionType1 e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 代码块2</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>exceptionType2 e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 代码块3</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果 try 语句块中发生异常，那么一个相应的异常对象就会被拋出，然后 catch 语句就会依据所拋出异常对象的类型进行捕获，并处理。处理之后，程序会跳过 try 语句块中剩余的语句，转到 catch 语句块后面的第一条语句开始执行</p><p>如果 try 语句块中没有异常发生，那么 try 块正常结束，后面的 catch 语句块被跳过，程序将从 catch 语句块后的第一条语句开始执行</p><p>catch处理异常，可以使用以下三种方式对异常信息进行输出</p><ul><li>e.printStackTrace()：指出异常的类型、性质、栈层次及出现在程序中的位置</li><li>e.getMessage()：返回异常的性质</li><li>e.toString()：返回异常的性质和类型</li></ul><p>finally用于指定无论try和catch中的代码是否执行完，都会执行的代码</p><h3 id="throws" tabindex="-1"><a class="header-anchor" href="#throws" aria-hidden="true">#</a> throws</h3><p>throws用于指定方法中可能发生的异常，编译器检查方法调用时是否处理了异常，如果处理了，则编译通过；如果未处理，则编译不通过</p><p>一般用于在该方法中不处理异常，交给方法的调用者</p><p>格式如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>returnType <span class="token function">methodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> 异常类<span class="token number">1</span><span class="token punctuation">,</span>异常类<span class="token number">2</span><span class="token punctuation">,</span>异常类<span class="token number">3</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="string" tabindex="-1"><a class="header-anchor" href="#string" aria-hidden="true">#</a> String</h2><p>String代表字符串类</p><h3 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h3><ol><li>java中所有的双引号字面值都是String类的对象实现</li><li>字符串是不可变的，对字符串进行拼接、截取、替换、转换、替换、遍历等操作，都会产生新的字符串对象，不会改变原来的字符串对象</li><li>相同的字符串在内存中只有一份对象，相同字符串内容的不同变量<code>共享</code>同一个对象</li></ol><h3 id="创建string对象" tabindex="-1"><a class="header-anchor" href="#创建string对象" aria-hidden="true">#</a> 创建String对象</h3><ol><li>通过字面值创建String对象:String s = &quot;hello&quot;;</li><li>通过有参构造传入字符串创建:String s = new String(&quot;hello&quot;);</li><li>通过char数组创建String对象:String s = new String(char[] {&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;});</li><li>通过字节数组创建String对象:String s = new String(byte[] {104,101,108,108,111});</li></ol><h3 id="常用方法" tabindex="-1"><a class="header-anchor" href="#常用方法" aria-hidden="true">#</a> 常用方法</h3><h4 id="比较方法" tabindex="-1"><a class="header-anchor" href="#比较方法" aria-hidden="true">#</a> 比较方法</h4><ol><li>boolean equals(String s) 判断两个字符串是否相等</li><li>boolean equalsIgnoreCase(String s) 忽略大小写判断两个字符串是否相等</li><li>int compareTo(String s) 比较两个字符串的大小</li><li>int compareToIgnoreCase(String s) 忽略大小写比较两个字符串的大小</li></ol><h4 id="获取方法" tabindex="-1"><a class="header-anchor" href="#获取方法" aria-hidden="true">#</a> 获取方法</h4><ol><li>int length() 获取字符串的长度</li><li>char charAt(int index) 获取指定索引处的字符</li><li>int indexOf(String s) 获取指定字符串在字符串中的索引</li><li>int indexOf(String s, int fromIndex) 获取指定字符串在字符串中的索引，从指定索引开始</li><li>int lastIndexOf(String s) 获取指定字符串在字符串中的索引，从字符串末尾开始</li><li>int lastIndexOf(String s, int fromIndex) 获取指定字符串在字符串中的索引，从指定索引开始，从字符串末尾开始</li><li>String substring(int beginIndex) 获取指定索引开始到字符串末尾的子字符串</li><li>String substring(int beginIndex, int endIndex) 获取指定索引开始到指定索引结束的子字符串</li></ol><h4 id="转换方法" tabindex="-1"><a class="header-anchor" href="#转换方法" aria-hidden="true">#</a> 转换方法</h4><ol><li>String toLowerCase() 将字符串转换为小写</li><li>String toUpperCase() 将字符串转换为大写</li><li>String trim() 删除字符串两端的空格</li><li>String replace(char oldChar, char newChar) 替换字符串中指定的字符</li><li>String replace(CharSequence target, CharSequence replacement) 替换字符串中指定的字符序列</li><li>String replaceAll(String regex, String replacement) 替换字符串中指定的正则表达式</li><li>String replaceFirst(String regex, String replacement) 替换字符串中指定的正则表达式的第一个匹配项</li><li>String[] split(String regex) 分割字符串，返回一个字符串数组</li><li>Char[] toCharArray() 将字符串转换为字符数组</li><li>byte[] getBytes() 将字符串转换为字节数组</li></ol><h4 id="拼接字符串" tabindex="-1"><a class="header-anchor" href="#拼接字符串" aria-hidden="true">#</a> 拼接字符串</h4><ol><li>String concat(String str) 拼接字符串，返回一个新串儿</li></ol><h4 id="判断方法" tabindex="-1"><a class="header-anchor" href="#判断方法" aria-hidden="true">#</a> 判断方法</h4><ol><li>boolean startsWith(String prefix) 判断字符串是否以指定前缀开头</li><li>boolean endsWith(String suffix) 判断字符串是否以指定后缀结尾</li><li>boolean contains(CharSequence seq) 判断字符串是否包含指定字符序列</li></ol><h3 id="stringbuilder" tabindex="-1"><a class="header-anchor" href="#stringbuilder" aria-hidden="true">#</a> StringBuilder</h3><p>stringBuilder 是一个可变字符串，主要用于字符串拼接，string使用+每拼接一次字符串，就会创建一个新的字符串对象，消耗内存；stringbuilder自带一个缓冲区，每次拼接都会将结果放到缓冲区，不会创建新的对象，拼接结束后，将缓冲区中的内容复制到新的字符串对象中，不会产生垃圾。</p><p>使用StringBuilder做字符串拼接， 线程是不安全的</p><h2 id="数学类" tabindex="-1"><a class="header-anchor" href="#数学类" aria-hidden="true">#</a> 数学类</h2><h3 id="math类" tabindex="-1"><a class="header-anchor" href="#math类" aria-hidden="true">#</a> Math类</h3><ol><li>int abs(int a)、long abs(long a)、double abs(double a)、float abs(float a)：求绝对值</li><li>double floor(double a)：向下取整，返回double a的整数部分</li><li>double ceil(double a)：向上取整</li><li>double round(double a)：四舍五入</li><li>int max(int a, int b)、long max(long a, long b)、double max(double a, double b)、float max(float a, float b)：求最大值</li><li>int min(int a, int b)、long min(long a, long b)、double min(double a, double b)、float min(float a, float b)：求最小值</li></ol><h3 id="biginteger类" tabindex="-1"><a class="header-anchor" href="#biginteger类" aria-hidden="true">#</a> BigInteger类</h3><ol><li>BigInteger add(BigInteger val)：求和</li><li>BigInteger subtract(BigInteger val)：求差</li><li>BigInteger multiply(BigInteger val)：求积</li><li>BigInteger divide(BigInteger val)：求商</li><li>BigInteger mod(BigInteger m)：求余</li><li>BigInteger pow(int n)：求幂</li></ol><h3 id="bigdecimal类" tabindex="-1"><a class="header-anchor" href="#bigdecimal类" aria-hidden="true">#</a> BigDecimal类</h3><ol><li>BigDecimal add(BigDecimal val)：求和</li><li>BigDecimal subtract(BigDecimal val)：求差</li><li>BigDecimal multiply(BigDecimal val)：求积</li><li>BigDecimal divide(BigDecimal val)：求商</li><li>BigDecimal divide(BigDecimal val, int scale, int roundingMode)：求商，scale表示精度，roundingMode表示舍入模式，可以解决除不尽的问题</li><li>BigDecimal pow(int n)：求幂</li></ol><h2 id="date类" tabindex="-1"><a class="header-anchor" href="#date类" aria-hidden="true">#</a> Date类</h2><p>1.new Date()：创建一个Date对象，该对象表示当前时间 2.new Date(long millis)：创建一个Date对象，该对象表示1970年1月1日0时0分0秒到当前时间之间所经过的毫秒数 3.Date.parse(String s)：将字符串s转换成Date对象，字符串s必须遵循&quot;yyyy-MM-dd HH:mm:ss&quot;的格式，否则将返回-1 4.Date.getTime()：返回1970年1月1日0时0分0秒到当前时间之间所经过的毫秒数 5.Date.toString()：返回当前时间对应的字符串，格式为&quot;EEE MMM dd HH:mm:ss zzz yyyy&quot; 6.Date.getYear()/Date.getFullYear：返回当前时间对应的年份，从1900年开始计算 7.Date.getMonth()：返回当前时间对应的月份，从0开始计算 8.Date.getDate()：返回当前时间对应的日期，从1开始计算 9.Date.getHours()：返回当前时间对应的小时，从0开始计算 10.Date.getMinutes()：返回当前时间对应的分钟，从0开始计算 11.Date.getSeconds()：返回当前时间对应的秒钟，从0开始计算 12.Date.getMilliseconds()：返回当前时间对应的毫秒，从0开始计算 13.Date.getDay()：返回当前时间对应的星期，从0开始计算，0表示星期天，1表示星期一，以此类推 14.Date.setTime(long time)：设置当前时间，参数为毫秒数</p><h2 id="calendar类" tabindex="-1"><a class="header-anchor" href="#calendar类" aria-hidden="true">#</a> Calendar类</h2><p>1.Calendar.getInstance()：获取当前时间对应的日历对象 2.Calendar.get(int field)：获取指定字段的值 3.Calendar.set(int field, int value)：设置指定字段的值 4.Calendar.add(int field, int amount)：将指定字段的值增加或减少指定的值 5.Calendar.getTime()：获取当前日历对应的时间对象 6.Calendar.getTimeInMillis()：获取当前日历对应时间的毫秒数 7.Calendar.get(Calendar.YEAR)：获取当前日历对应时间的年 8.Calendar.get(Calendar.MONTH)：获取当前日历对应时间的月 9.Calendar.get(Calendar.DAY_OF_MONTH)：获取当前日历对应时间的日 10.Calendar.get(Calendar.HOUR_OF_DAY)：获取当前日历对应时间的时 11.Calendar.get(Calendar.MINUTE)：获取当前日历对应时间的分 12.Calendar.get(Calendar.SECOND)：获取当前日历对应时间的秒 13.Calendar.get(Calendar.MILLISECOND)：获取当前日历对应时间的毫秒 14.Calendar.get(Calendar.DAY_OF_WEEK)：获取当前日历对应时间的星期几</p><h2 id="simpledateformat类" tabindex="-1"><a class="header-anchor" href="#simpledateformat类" aria-hidden="true">#</a> SimpleDateFormat类</h2><p>SimpleDateFormat类是java.text包下的类，用于格式化日期。 创建sdf对象，SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</p><ol><li>格式化日期：String format( Date date)</li><li>解析日期：Date parse(String source)</li></ol><h2 id="包装类" tabindex="-1"><a class="header-anchor" href="#包装类" aria-hidden="true">#</a> 包装类</h2><p>基本类型对应的类就是包装类，例如int对应的包装类是Integer</p><h3 id="拆箱与装箱" tabindex="-1"><a class="header-anchor" href="#拆箱与装箱" aria-hidden="true">#</a> 拆箱与装箱</h3><p>装箱：将基本类型转换为对应的包装类，如Integer提供了valueOf()方法。Integer i = Integer.valueOf(100);</p><p>拆箱：将包装类转换为对应的基本类型，如integer提供了intValue()方法。int a = i.intValue();</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Integer</span> chenmo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 手动装箱</span>
<span class="token keyword">int</span> wanger <span class="token operator">=</span> chenmo<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 手动拆箱</span>

<span class="token class-name">Integer</span> chenmo  <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment">// 自动装箱</span>
<span class="token keyword">int</span> wanger <span class="token operator">=</span> chenmo<span class="token punctuation">;</span>     <span class="token comment">// 自动拆箱</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>字符串转包装类：在包装类中，都有一个类似parseXXX的方法，用于将字符串转换为对应的基本类型。如Integer提供了parseInt()方法。int a = Integer.parseInt(&quot;100&quot;);</p><p>包装类转字符串：在包装类中，还有一个类似toString()的方法，用于将基本类型转换为字符串。如Integer提供了toString()方法。String s = Integer.toString(100);</p><blockquote><p>当需要进行自动装箱时，如果数字在 -128 至 127 之间时，会直接使用缓存中的对象，而不是重新创建一个对象</p></blockquote><h3 id="包装类型与基本类型的区别" tabindex="-1"><a class="header-anchor" href="#包装类型与基本类型的区别" aria-hidden="true">#</a> 包装类型与基本类型的区别</h3><ol><li>包装类型可以为null，基本类型不可以</li></ol><p>在POJO中，这点区别尤为重要，数据库的查询结果可能是null，如果使用基本类型，当自动拆箱时就是抛出<code>NullPointerException</code>异常</p><ol start="2"><li>基本类型比包装类型更高效</li></ol><p>作为局部变量时，基本数据类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用。相比较于基本类型而言，包装类型需要占用更多的内存空间，占用的内存空间要大得多，因为它们是对象，并且要存储对象的元数据，并且不仅要存储对象，还要存储引用</p><h3 id="数据存储区域" tabindex="-1"><a class="header-anchor" href="#数据存储区域" aria-hidden="true">#</a> 数据存储区域</h3><ol><li><p>寄存器。这是最快的存储区，因为它位于 CPU 内部，用来暂时存放参与运算的数据和运算结果。</p></li><li><p>栈：位于 RAM（Random Access Memory，也叫主存，与 CPU 直接交换数据的内部存储器）中，速度仅次于寄存器。但是，在分配内存的时候，存放在栈中的数据大小与生存周期必须在编译时是确定的，缺乏灵活性。基本数据类型的值和对象的引用通常存储在这块区域。</p></li><li><p>堆：也位于 RAM 区，可以动态分配内存大小，编译器不必知道要从堆里分配多少存储空间，生存周期也不必事先告诉编译器，Java 的垃圾收集器会自动收走不再使用的数据，因此可以得到更大的灵活性。但是，运行时动态分配内存和销毁对象都需要占用时间，所以效率比栈低一些。new 创建的对象都会存储在这块区域。</p></li><li><p>磁盘：如果数据完全存储在程序之外，就可以不受程序的限制，在程序没有运行时也可以存在。像文件、数据库，就是通过持久化的方式，让对象存放在磁盘上。当需要的时候，再反序列化成程序可以识别的对象。</p></li></ol><h2 id="工具类" tabindex="-1"><a class="header-anchor" href="#工具类" aria-hidden="true">#</a> 工具类</h2><h3 id="arrays" tabindex="-1"><a class="header-anchor" href="#arrays" aria-hidden="true">#</a> Arrays</h3><p>数组专用工具类指的是 java.util.Arrays 类，基本上常见的数组操作，这个类都提供了静态方法可供直接调用</p><h4 id="创建数组" tabindex="-1"><a class="header-anchor" href="#创建数组" aria-hidden="true">#</a> 创建数组</h4><ol><li>copyOf：复制指定的数组，如果长度小于数组长度则截取，如果长度大于数组长度则用<code>null</code>填充</li><li>copyOfRange：复制指定范围内的数组到一个新的数组</li><li>fill：对数组进行填充</li></ol><h4 id="比较数组" tabindex="-1"><a class="header-anchor" href="#比较数组" aria-hidden="true">#</a> 比较数组</h4><p>Arrays类的<code>equals()</code>方法用来判断两个数组是否相等，除了 equals() 方法，还有另外一个诀窍可以判断两个数组是否相等，尽管可能会出现误差。那就是Arrays.hashCode()方法</p><p>源码实现：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">==</span>a2<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">==</span><span class="token keyword">null</span> <span class="token operator">||</span> a2<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> length <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a2<span class="token punctuation">.</span>length <span class="token operator">!=</span> length<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="数组排序" tabindex="-1"><a class="header-anchor" href="#数组排序" aria-hidden="true">#</a> 数组排序</h4><p>Arrays类的sort()方法用来对数组进行排序，排序会改变原有的数组</p><h4 id="数组元素查询" tabindex="-1"><a class="header-anchor" href="#数组元素查询" aria-hidden="true">#</a> 数组元素查询</h4><p>数组排序后就可以使用Arrays类的binarySearch()方法进行二分查找，线性检索，效率就会低很多</p><p>Arrays.binarySearch()方法既可以精确检索，也可以模糊检索，比如说忽略大小写，Arrays.binarySearch(sorted, &quot;Wang&quot;, String::compareToIgnoreCase)</p><h4 id="数组打印" tabindex="-1"><a class="header-anchor" href="#数组打印" aria-hidden="true">#</a> 数组打印</h4><p>因为数组是一个对象，直接 System.out.println 的话，结果是对象的内存地址，要争取打印出数组，需要使用Arrays.toString()，源码实现如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token string">&quot;null&quot;</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> iMax <span class="token operator">=</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>iMax <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token string">&quot;[]&quot;</span><span class="token punctuation">;</span>

    <span class="token class-name">StringBuilder</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token char">&#39;[&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        b<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> iMax<span class="token punctuation">)</span>
            <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token char">&#39;]&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        b<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;, &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="数组转list" tabindex="-1"><a class="header-anchor" href="#数组转list" aria-hidden="true">#</a> 数组转List</h4><p>尽管数组非常强大，但它自身可以操作的工具方法很少，比如说判断数组中是否包含某个值。如果能转成 List 的话，需要使用Arrays.asList()方法，但是该方法返回的是java.util. Arrays.ArrayList类型，它的长度是固定的，无法进行元素的删除或者添加。要想操作元素的话，需要多一步转化，将返回值作为ArrayList构造函数的参数</p><p>代码示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="stringutils" tabindex="-1"><a class="header-anchor" href="#stringutils" aria-hidden="true">#</a> StringUtils</h3><p>StringUtils工具类用于对字符串判空，截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式</p><h4 id="字符串判空" tabindex="-1"><a class="header-anchor" href="#字符串判空" aria-hidden="true">#</a> 字符串判空</h4><p>空字符串，不只是null一种，还有&quot;&quot;，&quot; &quot;，&quot;null&quot;等等，多种情况</p><ol><li>isEmpty与isNotEmpty：用于判断是否是null或者&quot;&quot;</li><li>isBlank与isNotBlank：除了上述情况，会把&quot; &quot;也考虑进去</li></ol><h4 id="分隔字符串" tabindex="-1"><a class="header-anchor" href="#分隔字符串" aria-hidden="true">#</a> 分隔字符串</h4><p>分割字符串可以使用String类的split方法，但是可能会出现空指针异常，所以StringUtils提供了split方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="拼接字符串-1" tabindex="-1"><a class="header-anchor" href="#拼接字符串-1" aria-hidden="true">#</a> 拼接字符串</h4><p>将某个集合的内容，拼接成一个字符串，然后输出，这时可以使用join方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Lists</span><span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list2 <span class="token operator">=</span> <span class="token class-name">Lists</span><span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token string">&quot;,&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>list2<span class="token punctuation">,</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="其他方法" tabindex="-1"><a class="header-anchor" href="#其他方法" aria-hidden="true">#</a> 其他方法</h4><ul><li>trim(String str)：去除字符串首尾的空白字符。</li><li>trimToEmpty(String str)：去除字符串首尾的空白字符，如果字符串为 null，则返回空字符串。</li><li>trimToNull(String str)：去除字符串首尾的空白字符，如果结果为空字符串，则返回 null。</li><li>equals(String str1, String str2)：比较两个字符串是否相等。</li><li>equalsIgnoreCase(String str1, String str2)：比较两个字符串是否相等，忽略大小写。</li><li>startsWith(String str, String prefix)：检查字符串是否以指定的前缀开头。</li><li>endsWith(String str, String suffix)：检查字符串是否以指定的后缀结尾。</li><li>contains(String str, CharSequence seq)：检查字符串是否包含指定的字符序列。</li><li>indexOf(String str, CharSequence seq)：返回指定字符序列在字符串中首次出现的索引，如果没有找到，则返回 -1。</li><li>lastIndexOf(String str, CharSequence seq)：返回指定字符序列在字符串中最后一次出现的索引，如果没有找到，则返回 -1。</li><li>substring(String str, int start, int end)：截取字符串中指定范围的子串。</li><li>replace(String str, String searchString, String replacement)：替换字符串中所有出现的搜索字符串为指定的替换字符串。</li><li>replaceAll(String str, String regex, String replacement)：使用正则表达式替换字符串中所有匹配的部分。</li><li>join(Iterable&lt;?&gt; iterable, String separator)：使用指定的分隔符将可迭代对象中的元素连接为一个字符串。</li><li>split(String str, String separator)：使用指定的分隔符将字符串分割为一个字符串数组。</li><li>capitalize(String str)：将字符串的第一个字符转换为大写。</li><li>uncapitalize(String str)：将字符串的第一个字符转换为小写。</li></ul><h3 id="objects" tabindex="-1"><a class="header-anchor" href="#objects" aria-hidden="true">#</a> Objects</h3><p>Java 的 Objects 类是一个实用工具类，包含了一系列静态方法，用于处理对象。它位于 java.util 包中，自 Java 7 引入。Objects 类的主要目的是降低代码中的空指针异常 (NullPointerException) 风险</p><h4 id="对象判空" tabindex="-1"><a class="header-anchor" href="#对象判空" aria-hidden="true">#</a> 对象判空</h4><p>Objects的isNull 方法用于判断对象是否为空，而nonNull方法判断对象是否不为空，requireNonNull方法如果对象为空，抛出空指针异常</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Integer</span> integer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;对象为空&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;对象不为空&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>integer<span class="token punctuation">,</span> <span class="token string">&quot;参数不能为空&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>integer<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;参数不能为空&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="判断对象相等" tabindex="-1"><a class="header-anchor" href="#判断对象相等" aria-hidden="true">#</a> 判断对象相等</h4><p>要判断两个对象是否相等，Objects给我们提供了equals方法， Objects.equals()方法本身是用来避免坑的，因为它可以处理null值的比较，而不会抛出空指针异常。然而，这并不意味着它没有任何潜在问题。实际上，Objects.equals() 方法的一个潜在问题是依赖于被比较对象的equals()方法实现。当两个对象的类没有正确实现equals()方法时，Objects.equals()方法可能会产生不符合预期的结果，没有正确地实现equals()方法，默认情况下会使用Object类的 equals()方法，它只比较对象引用是否相同</p><h4 id="获取对象的hashcode" tabindex="-1"><a class="header-anchor" href="#获取对象的hashcode" aria-hidden="true">#</a> 获取对象的hashCode</h4><p>获取某个对象的 hashCode，可以使用 Objects 的 hashCode 方法</p><h4 id="比较数组-1" tabindex="-1"><a class="header-anchor" href="#比较数组-1" aria-hidden="true">#</a> 比较数组</h4><p>deepEquals()用于比较两个数组类型的对象，当对象是非数组的话，行为和equals()一致</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array3 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">deepEquals</span><span class="token punctuation">(</span>array1<span class="token punctuation">,</span> array2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：true（因为 array1 和 array2 的内容相同）</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">deepEquals</span><span class="token punctuation">(</span>array1<span class="token punctuation">,</span> array3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：false（因为 array1 和 array3 的内容不同）</span>

<span class="token comment">// 对于非数组对象，deepEquals() 的行为与 equals() 相同</span>
<span class="token class-name">String</span> string1 <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> string2 <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> string3 <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">deepEquals</span><span class="token punctuation">(</span>string1<span class="token punctuation">,</span> string2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：true（因为 string1 和 string2 相同）</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">deepEquals</span><span class="token punctuation">(</span>string1<span class="token punctuation">,</span> string3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：false（因为 string1 和 string3 不同）</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="collections" tabindex="-1"><a class="header-anchor" href="#collections" aria-hidden="true">#</a> Collections</h3><h4 id="排序操作" tabindex="-1"><a class="header-anchor" href="#排序操作" aria-hidden="true">#</a> 排序操作</h4><ol><li>reverse(List list)：反转顺序</li><li>shuffle(List list)：将顺序打乱</li><li>sort(List list)：自然升序</li><li>sort(List list, Comparator c)：按照自定义的比较器排序</li><li>swap(List list, int i, int j)：将 i 和 j 位置的元素交换位置</li></ol><h4 id="查找操作" tabindex="-1"><a class="header-anchor" href="#查找操作" aria-hidden="true">#</a> 查找操作</h4><ol><li>binarySearch(List list, Object key)：二分查找法，前提是 List 已经排序过了</li><li>max(Collection coll)：返回最大元素</li><li>max(Collection coll, Comparator comp)：根据自定义比较器，返回最大元素</li><li>min(Collection coll)：返回最小元素</li><li>min(Collection coll, Comparator comp)：根据自定义比较器，返回最小元素</li><li>fill(List list, Object obj)：使用指定对象填充</li><li>frequency(Collection c, Object o)：返回指定对象出现的次数</li></ol><h4 id="其他方法-1" tabindex="-1"><a class="header-anchor" href="#其他方法-1" aria-hidden="true">#</a> 其他方法</h4><ol><li>addAll(Collection&lt;? super T&gt; c, T... elements)，往集合中添加元素</li><li>disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2)，判断两个集合是否没有交集</li></ol><h2 id="多线程" tabindex="-1"><a class="header-anchor" href="#多线程" aria-hidden="true">#</a> 多线程</h2><p>进程：是系统分配资源的最小单位 线程：是系统执行任务(系统调度)的最小单元 并行：在同一时刻，有多个任务在多个cpu上同时进行 并发：在同一时刻，有多个任务在单个cpu上交替进行</p><h3 id="创建线程" tabindex="-1"><a class="header-anchor" href="#创建线程" aria-hidden="true">#</a> 创建线程</h3><h4 id="通过继承thread类" tabindex="-1"><a class="header-anchor" href="#通过继承thread类" aria-hidden="true">#</a> 通过继承Thread类</h4><ol><li>继承Thread类，并重写run()方法</li><li>使用子类创建对象</li><li>调用对象的start()方法启动线程，启动以后，jvm会自动调用run()方法</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;:打了&quot;</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">&quot;个小兵&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="通过实现runnable接口" tabindex="-1"><a class="header-anchor" href="#通过实现runnable接口" aria-hidden="true">#</a> 通过实现Runnable接口</h4><ol><li>创建Runnable接口的实现类，并重写run()方法</li><li>创建Thread对象，并将创建的Runnable接口实现类对象作为参数传递给Thread对象</li><li>调用start()方法启动线程</li></ol><p>实现Runnable接口</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token comment">//sleep会发生异常要显示处理</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//暂停20毫秒</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;打了:&quot;</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">&quot;个小兵&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建线程对象并调用start方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//创建MyRunnable类</span>
<span class="token class-name">MyRunnable</span> mr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//创建Thread类的有参构造,并设置线程名</span>
<span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>mr<span class="token punctuation">,</span> <span class="token string">&quot;张飞&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>mr<span class="token punctuation">,</span> <span class="token string">&quot;貂蝉&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Thread</span> t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>mr<span class="token punctuation">,</span> <span class="token string">&quot;吕布&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//启动线程</span>
t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="通过实现callable接口" tabindex="-1"><a class="header-anchor" href="#通过实现callable接口" aria-hidden="true">#</a> 通过实现Callable接口</h4><ol><li>创建Callable接口的实现类，并重写call()方法</li><li>创建FutureTask对象，将Callable接口实现类对象作为参数传递给FutureTask对象</li><li>创建Thread对象，将FutureTask对象作为参数传递给Thread对象</li><li>调用start()方法启动线程</li><li>调用FutureTask对象的get()方法获取线程执行结果</li></ol><blockquote><p>call方法与run方法的区别 call方法有返回值，run方法没有返回值 call方法可以抛出异常，run方法不可以抛出异常</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CallerTask</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;Hello,i am running!&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//创建异步任务</span>
        <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> task<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CallerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//启动线程</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">//等待执行完成，并获取返回结果</span>
            <span class="token class-name">String</span> result<span class="token operator">=</span>task<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池" aria-hidden="true">#</a> 线程池</h4><ol><li>使用Executors类中的static ExecutorService newFixedThreadPool(int nThreads)方法创建线程池</li><li>使用ExecutorService中的submit(Runnable task)方法提交任务</li></ol><h3 id="线程常用方法" tabindex="-1"><a class="header-anchor" href="#线程常用方法" aria-hidden="true">#</a> 线程常用方法</h3><ol><li>start()：启动线程，调用run()方法</li><li>run()：线程要执行的任务，线程启动后，会自动调用此方法，不应该在代码中主动调用</li><li>sleep(long millis)：让当前线程休眠指定的时间</li><li>setName(String name)：设置线程名称</li><li>getName()：获取线程名称</li><li>static currentThread()：返回当前线程对象</li><li>setPriority(int priority)：设置线程优先级</li><li>getPriority()：获取线程优先级</li><li>setDaemon(boolean on)：设置线程为守护线程，非守护线程结束后，守护线程也会结束</li><li>static void yield()：设置线程为礼让线程, 让当前线程暂停，但是不释放锁</li><li>join()：将线程插入到当前线程之前</li></ol><h3 id="线程安全" tabindex="-1"><a class="header-anchor" href="#线程安全" aria-hidden="true">#</a> 线程安全</h3><p>线程安全是指多个线程并发访问同一个数据时，产生数据不一致的问题。</p><ol><li>synchronized同步代码块：同步锁，保证线程安全 当一个线程拿到锁对象后，进入到同步代码块，其他线程拿到锁对象后，无法进入同步代码块，只能等待；当synchronized代码块执行完毕，锁对象释放，其他线程拿到锁对象后，进入同步代码块。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizeDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span>  <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// some codes</span>
            count<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>非静态同步方法,此时默认的锁对象就是所在对象，即this</li></ol><p>对有线程安全的代码使用synchronized修饰</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// some codes</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>静态同步方法,此时默认的锁对象就是所在类的Class对象</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// some codes</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="线程状态" tabindex="-1"><a class="header-anchor" href="#线程状态" aria-hidden="true">#</a> 线程状态</h3><ol><li>new=&gt;创建状态：线程对象创建后，还没有调用start()方法，线程处于new状态。</li><li>runnable=&gt;可运行状态：线程对象调用start()方法后，线程就进入可运行状态，此时可能在运行代码，也可能在等待cpu时间片。</li><li>blocked=&gt;阻塞状态：线程在等待锁的释放。</li><li>waiting=&gt;无限等待状态：一个线程等待另一个线程唤醒，使用空参调用了wait方法。</li><li>timed waiting=&gt;限时等待状态：一个线程等待另一个线程唤醒，调用了sleep或者有参wait方法。</li><li>terminated=&gt;结束状态：run方法执行完毕，或者有未捕获的异常终止了run方法，或者调用了过时的stop()方法，线程就进入终止状态。</li></ol><blockquote><p>wait方法和sleep方法都是Object类的方法，sleep方法属于Thread类。 wait方法：会释放锁，进入等待状态，当到达时间或者被其他线程唤醒后，会重新获取锁，获取到锁后继续执行 sleep方法：不会释放锁，进入等待状态，时间到后会醒来继续执行</p></blockquote><p><img src="`+t+'" alt="线程状态转换"></p><h2 id="集合" tabindex="-1"><a class="header-anchor" href="#集合" aria-hidden="true">#</a> 集合</h2><p>集合是一个长度可变的容器，提供了一系列方法来操作集合，集合中只能存放引用类型的数据，如果存放的是基本类型数据，那么会自动封装成对象。</p><p>单列集合：一个元素只包含一个部分</p><p>双列结合：一个元素含两个部分，如map包含key和value</p><p>集合的实现类</p><p>set接口、map接口和list接口都继承自collection接口，list接口下有ArrayList、LinkedList、Vector三种实现类，map接口下有HashMap、LinkedHashMap、TreeMap三种实现类，set接口下有HashSet、LinkedHashSet、TreeSet三种实现类</p><p>继承关系如下： <img src="'+p+`" alt="集合"></p><h3 id="单列集合" tabindex="-1"><a class="header-anchor" href="#单列集合" aria-hidden="true">#</a> 单列集合</h3><h4 id="collection" tabindex="-1"><a class="header-anchor" href="#collection" aria-hidden="true">#</a> Collection</h4><p>单列集合的顶级接口</p><p>创建一个集合</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> 对象名 <span class="token operator">=</span> <span class="token keyword">new</span> 实现类<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>常用方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token operator">:</span> 将元素添加到集合中

<span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Connection</span> connection<span class="token punctuation">)</span><span class="token operator">:</span> 将一个集合添加到当前集合后面，集合合并的效果

<span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token operator">:</span> 从集合中删除指定元素，删除成功返回<span class="token boolean">true</span>

<span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> 清除集合中的所有元素

<span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token operator">:</span> 判断集合中是否含有某个元素

<span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> 查询集合是否为空

<span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> 查询集合中元素的数量

<span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> 将集合中的元素转换为数组形式
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>迭代器</p><p>通过集合的iterator方法可以获取集合的迭代器</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> al <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> iterator <span class="token operator">=</span> al<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">boolean</span> hasNext <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token class-name">String</span> next <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="arraylist" tabindex="-1"><a class="header-anchor" href="#arraylist" aria-hidden="true">#</a> ArrayList</h4><p>底层由数组实现，线程不安全；ArrayList中的元素都是有序、有索引的，并且可以重复</p><p>创建一个ArrayList：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> alist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>由于 ArrayList 实现了 List 接口，所以 alist 变量的类型可以是 List 类型；new 关键字声明后的尖括号中可以不再指定元素的类型，因为编译器可以通过前面尖括号中的类型进行智能推断</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> alist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果非常确定 ArrayList 中元素的个数，在创建的时候还可以指定初始大小，可以有效地避免在添加新的元素时进行不必要的扩容</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> alist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>常用方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token operator">:</span> 将元素添加到指定位置

<span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token operator">:</span> 将元素添加list中

<span class="token class-name">E</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token operator">:</span> 将指定位置的元素设置为新的元素，返回被替换的元素

<span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token operator">:</span> 删除指定位置的元素，并返回删除的元素

<span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span> <span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token operator">:</span> 删除指定的元素，并返回删除的结果

<span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token operator">:</span> 获取指定位置的元素

<span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> 获取集合中元素的个数

<span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token operator">:</span> 查询指定元素在集合中的索引，如果元素不存在，则返回<span class="token operator">-</span><span class="token number">1</span>

<span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token operator">:</span> 从后往前查询指定元素在集合中的索引，如果元素不存在，则返回<span class="token operator">-</span><span class="token number">1</span>

<span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token operator">:</span> 判断集合中是否包含某个元素
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="linkedlist" tabindex="-1"><a class="header-anchor" href="#linkedlist" aria-hidden="true">#</a> LinkedList</h4><p>底层由链表实现，线程不安全；LinkedList中的元素是有序、有基于索引的操作方法，本质没有索引，并且可以重复</p><p>常用方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token operator">:</span> 在链表开头添加元素

<span class="token keyword">void</span> <span class="token function">addLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token operator">:</span> 在链表末尾添加元素

<span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：删除头部的元素并返回

<span class="token class-name">E</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> 删除链表开头的元素，并返回删除的元素

<span class="token class-name">E</span> <span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> 删除链表末尾的元素，并返回删除的元素

<span class="token class-name">E</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span><span class="token class-name">E</span> e<span class="token punctuation">)</span>：修改指定位置的元素，并返回该位置之前的元素

<span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token operator">:</span> 查询指定元素在集合中的索引，如果元素不存在，则返回<span class="token operator">-</span><span class="token number">1</span>

<span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span>：获取指定位置的元素

<span class="token class-name">E</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> 获取链表开头的元素

<span class="token class-name">E</span> <span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> 获取链表末尾的元素

<span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token operator">:</span> 添加元素到头部

<span class="token class-name">E</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> 删除链表开头的元素，并返回删除的元素
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="hashset" tabindex="-1"><a class="header-anchor" href="#hashset" aria-hidden="true">#</a> HashSet</h4><p>底层由哈希表实现，线程不安全；HashSet中的元素是无序、无索引的，并且不能重复</p><h4 id="linkedhashset" tabindex="-1"><a class="header-anchor" href="#linkedhashset" aria-hidden="true">#</a> LinkedHashSet</h4><p>底层由链表+哈希表实现，线程不安全；LinkedHashSet中的元素是有序、无索引的，并且不能重复</p><h4 id="treeset" tabindex="-1"><a class="header-anchor" href="#treeset" aria-hidden="true">#</a> TreeSet</h4><p>底层由红黑树实现，线程不安全；TreeSet可以对元素进行排序，元素没有索引，并且不能重复</p><h4 id="集合工具类" tabindex="-1"><a class="header-anchor" href="#集合工具类" aria-hidden="true">#</a> 集合工具类</h4><p>Collection工具类提供了一系列静态方法，用于操作集合，类名为Collections，工具类的构造方法私有，不能创建对象，方法都是静态的</p><p>常用方法</p><p>public static void reverse(List list): 反转集合中的元素顺序</p><p>public static void addAll(Collection c1, Collection c2): 将c2集合中的元素添加到c1集合中</p><p>public static void shuffle(List list): 随机打乱集合中的元素顺序</p><p>public static void sort(List list): 对集合中的元素按照默认规则(ascII码值)排序</p><p>public static void sort(List list, Comparator c): 对集合中的元素进行指定排序</p><p>public static void swap(List list, int i, int j): 交换集合中指定位置的元素</p><p>public static int binarySearch(List list, Object key): 二分查找集合中指定元素，返回索引，找不到返回-1</p><p>public static int frequency(Collection c, Object o): 统计集合中指定元素的数量</p><p>public static void copy(List dest, List src): 将src集合中的元素复制到dest集合中</p><p>public static boolean replaceAll(List list, Object oldVal, Object newVal): 替换集合中的元素，返回替换的元素数量</p><h3 id="双列集合" tabindex="-1"><a class="header-anchor" href="#双列集合" aria-hidden="true">#</a> 双列集合</h3><h4 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> Map</h4><p>Map是双列集合的顶级接口 <img src="`+l+`" alt="map"></p><h4 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap" aria-hidden="true">#</a> hashMap</h4><p>具有key唯一，无序无索引，线程不安全，可以存null键null值的特点，底层结构是hash表</p><p>常用方法：</p><ul><li>V put(K key, V value): 添加/修改元素，返回被覆盖的value，如果没有发生覆盖，返回null</li><li>V get(Object key): 获取指定key对应的value</li><li>V remove(Object key): 删除指定key对应的元素，并返回被删除的value</li><li>boolean containsKey(Object key): 判断集合中是否包含指定key</li><li>boolean containsValue(Object value): 判断集合中是否包含指定value</li><li>Collection values(): 获取集合中所有value</li><li>Set entrySet(): 获取集合中所有key和value</li><li>Set keySet(): 获取集合中所有key</li></ul><h4 id="linkedhashmap" tabindex="-1"><a class="header-anchor" href="#linkedhashmap" aria-hidden="true">#</a> linkedHashMap</h4><p>继承自hashMap，有序无索引，线程不安全，可以存null键null值，底层结构式hash表+双向链表</p><p>常用方法同hashMap</p><h4 id="hashtable" tabindex="-1"><a class="header-anchor" href="#hashtable" aria-hidden="true">#</a> hashTable</h4><p>key唯一，value可重复，无序无索引，线程安全，不可以存null键null值，底层结构是hash表</p><h4 id="properties" tabindex="-1"><a class="header-anchor" href="#properties" aria-hidden="true">#</a> properties</h4><p>继承自hashTable，key和value都是string，key不能重复，value可重复，无序无索引，线程安全，不可以存null键null值，底层结构是hash表</p><p>常用方法同hashTable，特有方法：</p><ul><li>String getProperty(String key): 获取指定key对应的value</li><li>String getProperty(String key, String defaultValue): 获取指定key对应的value，如果key不存在，返回默认值</li><li>Object setProperty(String key, String value): 设置指定key对应的value</li><li>void load(InputStream inStream): 从输入流中加载数据</li><li>Set&lt;String&gt; stringPropertyNames(): 获取所有key</li></ul><h4 id="treemap" tabindex="-1"><a class="header-anchor" href="#treemap" aria-hidden="true">#</a> TreeMap</h4><p>key唯一，可对key进行排序，value可重复，无序无索引，线程不安全，不可以存null键null值，底层结构是红黑树</p><h2 id="泛型" tabindex="-1"><a class="header-anchor" href="#泛型" aria-hidden="true">#</a> 泛型</h2><p>在定义时无法确定具体的类型，需要等到使用的时候才能确定类型，为了避免数据类型转换异常，可以使用泛型，泛型可以理解为参数化的类型，泛型可以用在集合、数组、方法、类、接口等地方</p><h3 id="定义泛型" tabindex="-1"><a class="header-anchor" href="#定义泛型" aria-hidden="true">#</a> 定义泛型</h3><p>定义泛型类</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericClass</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> t<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>   
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义泛型方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>修饰符 <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> 返回值类型 方法名<span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
修饰符 <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> 返回值类型 方法名<span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 在调用时确定类型</span>
修饰符 <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> 返回值类型 方法名<span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span><span class="token class-name">T</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>t<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义泛型接口</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">GenericInterface</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">GenericClass</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">GenericInterface</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">GenericClass</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">GenericInterface</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>泛型类、泛型方法、泛型接口的泛型参数可以有多个，多个参数之间用逗号隔开，如：&lt;T1,T2,T3&gt;</p><h3 id="类型限定" tabindex="-1"><a class="header-anchor" href="#类型限定" aria-hidden="true">#</a> 类型限定</h3><p>类型限定规定在使用泛型类、泛型方法、泛型接口时，只能使用限定的参数类型及其继承的子类</p><h3 id="通配符" tabindex="-1"><a class="header-anchor" href="#通配符" aria-hidden="true">#</a> 通配符</h3><ol><li>泛型通配符：&lt;?&gt;</li></ol><p>泛型通配符?可以表示任意类型，如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2"><li>泛型上限：&lt;? extends 类型&gt;</li></ol><p>问号只能接收extends类型的本类类型及其子类类型，如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="3"><li>泛型下限：&lt;? super 类型&gt;</li></ol><p>问号只能接收super类型的本类类型及其父类类型，如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="io" tabindex="-1"><a class="header-anchor" href="#io" aria-hidden="true">#</a> IO</h2><h3 id="文件操作" tabindex="-1"><a class="header-anchor" href="#文件操作" aria-hidden="true">#</a> 文件操作</h3><p>File类是java.io包下的类，用于操作文件</p><h4 id="静态成员" tabindex="-1"><a class="header-anchor" href="#静态成员" aria-hidden="true">#</a> 静态成员</h4><ul><li>public static final String pathSeparator: 与系统有关的路径分隔符，如：Windows是; Linux是:</li><li>public static final String separator: 与系统有关的路径名称分隔符，如：Windows是\\ Linux是/</li></ul><h4 id="构造方法" tabindex="-1"><a class="header-anchor" href="#构造方法" aria-hidden="true">#</a> 构造方法</h4><ul><li>public File(String pathname): 根据文件路径创建File对象</li><li>public File(String parent, String child): 根据父路径和子路径创建File对象</li><li>public File(File parent, String child): 根据父File对象和子路径创建File对象</li></ul><h4 id="常用方法-1" tabindex="-1"><a class="header-anchor" href="#常用方法-1" aria-hidden="true">#</a> 常用方法</h4><ul><li>public String getPath(): 获取路径，new对象时传入的路径</li><li>public String getAbsolutePath(): 获取绝对路径，如果new对象时传入的路径是绝对路径，则返回该路径，否则返回当前路径+new对象时传入的路径</li><li>public String getName(): 获取文件或文件夹名称</li><li>public boolean exists(): 判断文件或文件夹是否存在</li><li>public boolean isFile(): 判断是否是文件</li><li>public boolean isDirectory(): 判断是否是文件夹</li><li>long length(): 获取文件的字节大小</li><li>boolean createNewFile(): 创建文件，创建成功返回true，否则返回false</li><li>boolean mkdir(): 创建文件夹，创建成功返回true，否则返回false</li><li>boolean mkdirs(): 创建文件夹,可创建多级文件夹，创建成功返回true，否则返回false</li><li>boolean delete(): 删除文件或者文件夹，删除成功返回true，否则返回false，删除的内容不会在回收站中；如果删除的是文件夹，则文件夹必须为空才能删除成功</li><li>String[] list(): 获取文件夹下的所有文件名</li><li>File[] listFiles(): 获取文件夹下的所有文件</li></ul><h3 id="io流" tabindex="-1"><a class="header-anchor" href="#io流" aria-hidden="true">#</a> IO流</h3><p>流（Stream），是一个抽象的概念，是指一连串的数据（字符或字节），是以先进先出的方式发送信息的通道。</p><p>当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据的时候，就会开启一个通向目的地的流。这时候你就可以想象数据好像在这其中“流”动一样。</p><p>一般来说关于流的特性有下面几点：</p><ol><li>先进先出：最先写入输出流的数据最先被输入流读取到。</li><li>顺序存取：可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节，不能随机访问中间的数据。（RandomAccessFile除外）</li><li>只读或只写：每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流。</li></ol><h4 id="fileoutputstream" tabindex="-1"><a class="header-anchor" href="#fileoutputstream" aria-hidden="true">#</a> FileOutputStream</h4><p>文件输出流，是抽象类OutputStream的子类</p><p>构造方法：</p><ul><li>FileOutputStream(File file)：传入一个文件对象</li><li>FileOutputStream(String name)：传入一个文件路径，指定文件如果没有，则会自动创建，如果有，则会创建一个对老的文件进行覆盖</li><li>FileOutputStream(File file, boolean append)：传入一个文件对象，第二个参数表示是否追加，true表示追加，false表示覆盖</li><li>FileOutputStream(String name, boolean append)：传入一个文件路径，第二个参数表示是否追加，true表示追加，false表示覆盖</li></ul><p>常用方法：</p><ul><li>void write(byte b)：向硬板写入一个字节</li><li>void write(byte[] b)：向硬板写入一个字节数组</li><li>void write(byte[] b, int off, int length)：向硬盘写入一个字节数组的一部分</li><li>void close()：关闭输出流，此时流对象就不能再使用了</li></ul><h4 id="fileinputstream" tabindex="-1"><a class="header-anchor" href="#fileinputstream" aria-hidden="true">#</a> FileInputStream</h4><p>文件输入流，是抽象类InputStream的子类</p><p>构造方法：</p><ul><li>FileInputStream(File file)：创建一个输入流，该输入流从指定的File对象表示的文件中读取字节</li><li>FileInputStream(String name)：创建一个输入流，该输入流从指定的文件名中读取字节</li></ul><blockquote><p>如果硬板中不存在该文件，则抛出FileNotFoundException异常，不会创建文件</p></blockquote><p>常用方法：</p><ul><li>int read()：从输入流中读取一个字节</li><li>int read(byte[] b)：从输入流中读取字节数组，返回读取的个数</li><li>int read(byte[] b, int off, int len)：从输入流中读取字节数组，返回读取的个数</li><li>void close()：关闭输入流</li></ul><h4 id="filereader" tabindex="-1"><a class="header-anchor" href="#filereader" aria-hidden="true">#</a> FileReader</h4><p>FileReader类继承Reader类，用于从文件中读取字符。</p><p>构造方法：</p><ul><li>FileReader(File file)</li><li>FileReader(String fileName)</li></ul><p>常用方法：</p><ul><li>int read()：一次一个字符，返回读取的字符，如果到达文件末尾，则返回-1</li><li>int read(char[] cbuf)：一次一个字符数组，返回读取的字符个数</li><li>int read(char[] cbuf, int off, int len)：一次一个字符数组，返回读取的个数</li><li>void close()：关闭输入流</li></ul><h4 id="filewriter" tabindex="-1"><a class="header-anchor" href="#filewriter" aria-hidden="true">#</a> FileWriter</h4><p>FileWriter类继承Writer类，用于向文件中写入字符。</p><p>构造方法：</p><ul><li>FileWriter(File file)：创建一个向指定File对象表示的文件中写入数据的FileWriter对象</li><li>FileWriter(String fileName)：创建一个向具有指定名称的文件中写入数据的FileWriter对象</li><li>FileWriter(File file, boolean append)：创建一个向指定File对象表示的文件中写入数据的FileWriter对象，如果第二个参数为true，则将数据写入文件末尾，而不是写入文件开头</li></ul><p>常用方法：</p><ul><li>void write(int c)：写入单个字符</li><li>void write(char[] cbuf)：写入字符数组</li><li>void write(char[] cbuf, int off, int len)：写入字符数组的某一部分</li><li>void write(String str)：写入字符串</li><li>void write(String str, int off, int len)：写入字符串的某部分</li><li>void flush()：刷新该流的缓冲，将缓冲区的数据刷入到文件中</li><li>void close()：关闭此流并释放与之关联的所有资源</li></ul><h4 id="bufferedinputstream" tabindex="-1"><a class="header-anchor" href="#bufferedinputstream" aria-hidden="true">#</a> BufferedInputStream</h4><p>BufferedInputStream(InputStream in)创建一个字节缓冲流 BufferedInputStream，它将输入数据读入一个缓冲区，缓冲区会自动扩容</p><h4 id="bufferedoutputstream" tabindex="-1"><a class="header-anchor" href="#bufferedoutputstream" aria-hidden="true">#</a> BufferedOutputStream</h4><p>BufferedOutputStream(OutputStream out)创建一个字节缓冲流 BufferedOutputStream，它将输入数据写入一个缓冲区，缓冲区会自动扩容</p><h4 id="bufferedreader" tabindex="-1"><a class="header-anchor" href="#bufferedreader" aria-hidden="true">#</a> BufferedReader</h4><p>BufferedReader(Reader in)创建一个字符缓冲流 BufferedReader，它将输入数据读入一个缓冲区，缓冲区会自动扩容</p><h4 id="bufferedwriter" tabindex="-1"><a class="header-anchor" href="#bufferedwriter" aria-hidden="true">#</a> BufferedWriter</h4><p>BufferedWriter(Writer out)创建一个字符缓冲流 BufferedWriter，它将输入数据写入一个缓冲区，缓冲区会自动扩容</p><h2 id="反射" tabindex="-1"><a class="header-anchor" href="#反射" aria-hidden="true">#</a> 反射</h2><h3 id="获取class对象" tabindex="-1"><a class="header-anchor" href="#获取class对象" aria-hidden="true">#</a> 获取Class对象</h3><ol><li>Class.forName(&quot;包名.类名&quot;)</li><li>对象.getClass()</li><li>类名.class</li></ol><h3 id="获取class对象的构造方法" tabindex="-1"><a class="header-anchor" href="#获取class对象的构造方法" aria-hidden="true">#</a> 获取class对象的构造方法</h3><p>获取所有public构造方法</p><p>Constructor&lt;?&gt;[] constructors = class.getConstructors();</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> aClass <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
<span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> constructors <span class="token operator">=</span> aClass<span class="token punctuation">.</span><span class="token function">getConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">:</span> constructors<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取空参的public构造方法</p><p>Constructor&lt;?&gt; constructor = class.getConstructor();</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> bClass  <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span>
<span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">=</span> bClass<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 使用构造方法创建对象</span>
constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取有参的public构造方法</p><p>Constructor&lt;?&gt; constructor = class.getConstructor(Class&lt;?&gt;...parameterTypes)</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> cClass <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
<span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">=</span> cClass<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 使用构造方法创建对象</span>
constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">&quot;张三&quot;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取所有构造方法 Constructor&lt;?&gt;[] constructors = class.getDeclaredConstructors()</p><p>获取指定的构造方法</p><p>Constructor&lt;?&gt; constructor = class.getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</p><p>解除私有构造限制</p><p>constructor.setAccessible(true);</p><h3 id="获取class对象的成员方法" tabindex="-1"><a class="header-anchor" href="#获取class对象的成员方法" aria-hidden="true">#</a> 获取class对象的成员方法</h3><p>获取所有的public方法</p><p>Method[] methods = class.getMethods()</p><p>获取指定的public方法</p><p>Method method = class.getMethod(methodName, Class&lt;?&gt;...parameterTypes)</p><p>调用通过反射获取到的方法</p><p>method.invoke(Object object, Object... parameterValues)</p><p>获取所有方法，包括private</p><p>Method[] methods = class.getDeclaredMethods()</p><p>获取指定的方法，包括private</p><p>Method method = class.getDeclaredMethod(methodName, Class&lt;?&gt;...parameterTypes)</p><p>解除私有方法限制</p><p>method.setAccessible(true)</p><h3 id="获取class对象的成员变量" tabindex="-1"><a class="header-anchor" href="#获取class对象的成员变量" aria-hidden="true">#</a> 获取class对象的成员变量</h3><p>获取所有public成员变量</p><p>Field[] fields = class.getFields()</p><p>获取指定的public成员变量</p><p>Field field = class.getField(fieldName)</p><p>获取所有成员变量</p><p>Field[] fields = class.getDeclaredFields()</p><p>获取指定的成员变量</p><p>Field field = class.getDeclaredField(fieldName)</p><p>解除成员变量限制</p><p>field.setAccessible(true)</p><p>获取成员变量的值</p><p>Object value = field.get(Object object)</p><p>设置成员变量的值</p><p>field.set(Object obj, Object val))</p><h2 id="注解" tabindex="-1"><a class="header-anchor" href="#注解" aria-hidden="true">#</a> 注解</h2><h3 id="注解的作用" tabindex="-1"><a class="header-anchor" href="#注解的作用" aria-hidden="true">#</a> 注解的作用</h3><p>说明：对代码进行说明，生成api文档</p><p>检查：检查代码是否符合条件，如@Override检查方式是否为重写方法，@FunctionalInterface检查是否为函数式接口</p><p>分析：对代码进行分析，起到代替配置文件的作用</p><h3 id="注解的生命周期" tabindex="-1"><a class="header-anchor" href="#注解的生命周期" aria-hidden="true">#</a> 注解的生命周期</h3><ol><li>SOURCE：@Retention(RetentionPolicy.SOURCE)，在源文件中有效，被编译器丢弃</li><li>CLASS：@Retention(RetentionPolicy.CLASS)，在class文件中有效，被JVM加载，但JVM退出时丢弃</li><li>RUNTIME：@Retention(RetentionPolicy.RUNTIME)，在JVM加载时有效，可以通过反射获取注解信息，并根据注解的定义执行相应的代码</li></ol><h3 id="注解的作用目标" tabindex="-1"><a class="header-anchor" href="#注解的作用目标" aria-hidden="true">#</a> 注解的作用目标</h3><p>注解的目标定义了注解将适用于哪一种级别的 Java 代码上，有些注解只适用于方法，有些只适用于成员变量，有些只适用于类，有些则都适用。截止到 Java 9，注解的类型一共有 11 种，定义在 ElementType 枚举中。</p><ul><li>TYPE：用于类、接口、注解、枚举</li><li>FIELD：用于字段（类的成员变量），或者枚举常量</li><li>METHOD：用于方法</li><li>PARAMETER：用于普通方法或者构造方法的参数</li><li>CONSTRUCTOR：用于构造方法</li><li>LOCAL_VARIABLE：用于变量</li><li>ANNOTATION_TYPE：用于注解</li><li>PACKAGE：用于包</li><li>TYPE_PARAMETER：用于泛型参数</li><li>TYPE_USE：用于声明语句、泛型或者强制转换语句中的类型</li><li>MODULE：用于模块</li></ul><h3 id="注解的定义" tabindex="-1"><a class="header-anchor" href="#注解的定义" aria-hidden="true">#</a> 注解的定义</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">FIELD</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> 注解名称 <span class="token punctuation">{</span>
    数据类型 属性名<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    数据类型 属性名<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> 默认值<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数据类型可以是8中基本类型、String、Class、enum、注解以及以上的一维数组组合</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">FIELD</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Book</span><span class="token punctuation">{</span>
    <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">12.34</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="注解的使用" tabindex="-1"><a class="header-anchor" href="#注解的使用" aria-hidden="true">#</a> 注解的使用</h3><p>注解的使用本质上是给注解的属性赋值，注解可以在类、方法、属性、参数、局部变量上使用</p><p>使用格式：</p><ul><li>@注解名(属性名=值,属性名=值)</li><li>@注解名(属性名={a,b,c},属性名=属性值)</li><li>@注解名(value=值)，这种情况可以省略value使用<code>@注解名(值)</code>的形式</li></ul><h3 id="注解的解析" tabindex="-1"><a class="header-anchor" href="#注解的解析" aria-hidden="true">#</a> 注解的解析</h3><p>注解的解析，本质上是将注解中的属性值获取出来</p><h2 id="spring-boot参数配置" tabindex="-1"><a class="header-anchor" href="#spring-boot参数配置" aria-hidden="true">#</a> spring boot参数配置</h2><h3 id="文件属性配置" tabindex="-1"><a class="header-anchor" href="#文件属性配置" aria-hidden="true">#</a> 文件属性配置</h3><ol><li>application.properties</li></ol><p>此方式使用key=value的方式对程序支持参数配置，如server.port=8080</p><ol start="2"><li>application.yml</li></ol><p>此方式使用两个空格缩进的方式来表示属性的层级，在yml文件中，缩进表示层级关系，而空格表示键值对之间的间隔，也就是yml文件比properties文件更易读。属性的冒号后要使用一个空格，如</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>application.yaml</li></ol><p>与yml的方式相同</p><p>优先级关系：</p><p>application.properties &gt; application.yml &gt; application.yaml &gt; application-{env}.yml &gt; application-{env}.yaml</p><h3 id="系统属性配置" tabindex="-1"><a class="header-anchor" href="#系统属性配置" aria-hidden="true">#</a> 系统属性配置</h3><p>系统属性可以在ida中进行配置，格式为：-Dkey=value，如：-Dserver.port=8080</p><p>也可以在启动命令行中进行指定，如java -jar xxx.jar --Dserver.port=8080</p><h3 id="命令行参数配置" tabindex="-1"><a class="header-anchor" href="#命令行参数配置" aria-hidden="true">#</a> 命令行参数配置</h3><p>命令行参数可以在ida中进行配置，格式为：--key=value，如：--server.port=8080，优先级高于系统属性</p><p>也可以在启动命令行中进行指定，如java -jar xxx.jar --server.port=8080</p><blockquote><p>参数配置优先级从高到低 命令行参数 &gt; 系统属性 &gt; properties &gt; yml &gt; yaml</p></blockquote>`,583),o=[c];function r(u,d){return a(),s("div",null,o)}const h=n(i,[["render",r],["__file","java-grammar-base.html.vue"]]);export{h as default};
