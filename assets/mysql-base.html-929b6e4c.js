import{_ as t,p as e,q as d,Y as l}from"./framework-e1bed10d.js";const i={},a=l('<h1 id="mysql" tabindex="-1"><a class="header-anchor" href="#mysql" aria-hidden="true">#</a> MySQL</h1><h2 id="数据模型" tabindex="-1"><a class="header-anchor" href="#数据模型" aria-hidden="true">#</a> 数据模型</h2><p>关系型数据库</p><p>建立在关系型数据模型上，由多张二维表相互连接组成的数据库</p><p>sql语句通用语法</p><ul><li>sql语句可以单行或者多行书写，以分号结尾</li><li>sql语句可以使用空格或缩进来增强sql语句的可读性</li><li>sql语句可以不区分大小写，但建议使用大写</li><li>sql语句可以注释，使用#作为单行注释，使用/**/作为多行注释，在mysql中还可以使用#来进行单行注释</li></ul><h2 id="sql语句分类" tabindex="-1"><a class="header-anchor" href="#sql语句分类" aria-hidden="true">#</a> sql语句分类</h2><ol><li>DDL语句：数据库定义语言，用于创建和删除数据库、表、字段</li></ol><ul><li>查询所有数据库: show databases;</li><li>查询当前使用的数据库：select database();</li><li>创建数据库：create database [if not exists] 数据库名;</li><li>删除数据库：drop database [if exists] 数据库名;</li><li>使用数据库：use 数据库名;</li><li>创建表：create table 表名(字段1 字段1类型 [约束] [comment 字段1注释 ],字段2 字段2类型 [约束] [comment 字段2注释 ],......字段n 字段n类型 [约束] [comment 字段n注释 ] ) [ comment 表注释 ] ;</li><li>删除表：drop table [if exists] 表名;</li><li>修改表名: rename table 表名 to 新表名;</li><li>查询表结构：desc 表名;</li><li>查询所有的表: show tables;</li><li>查询建表语句：show create table 表名;</li><li>添加字段：alter table 表名 add 字段名称 字段类型(长度) [comment 注释] [约束]</li><li>修改字段类型：alter table 表名 modify 字段名称 字段类型(长度) [comment 注释] [约束]</li><li>修改字段名称和类型：alter table 表名 change 旧名称字段 新名称字段 字段类型(长度) [comment 注释] [约束]</li><li>删除字段：alter table 表名 drop column 字段名称;</li></ul><blockquote><p>字段约束用于保证表中字段数据的正确性和完整性，是作用于字段的规则</p><ol><li>非空约束 not null：存储在表中的字段数据不能为null</li><li>唯一约束 unique：存储在表中的字段数据必须唯一，不能重复</li><li>主键约束 primary key：存储在表中的字段数据必须唯一且不能重复，并且不能为null</li><li>默认约束 default：如果没有指定字段的值，则使用默认值</li><li>外键约束 foreign key：让两张表建立联系</li></ol></blockquote><ol start="2"><li>DML语句：数据库操作语言，用于对数据的增删改</li></ol><ul><li>添加表指定字段数据：insert into 表名(字段1,字段2,字段3) values<a href=",(%E5%80%BC1,%E5%80%BC2,%E5%80%BC3)">值1,值2,值3</a></li><li>添加表所有字段数据：insert into 表名 values(值1,值2,值3,...),(值1,值2,值3,...)</li><li>修改表指定字段数据：update 表名 set 字段1=值1,字段2=值2,字段3=值3 [where 条件]</li><li>删除表指定字段数据：delete from 表名 [where 条件]</li></ul><ol start="3"><li>DQL语句：数据库查询语言，用于对数据的查询</li><li>DCL语句：数据库控制语言，用于操作数据库的用户及权限</li></ol><h2 id="dql" tabindex="-1"><a class="header-anchor" href="#dql" aria-hidden="true">#</a> DQL</h2><h3 id="基本查询" tabindex="-1"><a class="header-anchor" href="#基本查询" aria-hidden="true">#</a> 基本查询</h3><ol><li>查询所有字段：select * from 表名</li><li>查询多个字段：select 字段1,字段2[,...] from 表名</li><li>查询后设置别名 select 字段1 [as] 字段1别名,字段2 from 表名</li><li>查询后去除重复值 select distinct 字段列表 from 表名</li></ol><h3 id="条件查询" tabindex="-1"><a class="header-anchor" href="#条件查询" aria-hidden="true">#</a> 条件查询</h3><p>基本语句：select 字段列表 from 表名 where 条件列表</p><p>运算符</p><p>条件列表中的条件运算符主要分为比较运算符和逻辑运算符</p><p>比较运算符：</p><ul><li>&gt;, &gt;=, &lt;, &lt;=, =, !=：做相等和大小判断</li><li>between A and B：在A与B的这个范围之内</li><li>in (...)：值为in后面的列表之一</li><li>like 占位符：模糊匹配，_匹配单个字符，%匹配任意个字符，包括0个</li><li>is null：值为null，不能使用<code>=null</code></li><li>is not null：值不为null</li></ul><p>逻辑运算符：</p><ul><li>and或者&amp;&amp;：逻辑与，同时满足</li><li>or或者||；逻辑或，满足其中一个</li><li>not或者!：逻辑非，不满足条件</li></ul><h3 id="分组查询" tabindex="-1"><a class="header-anchor" href="#分组查询" aria-hidden="true">#</a> 分组查询</h3><p>分组查询语法：select 字段列表 from 表名 [where 条件列表] group by 分组字段名 [having 分组后过滤条件]</p><p>示例：select gender,count(&quot;date&quot;) as &quot;date_count&quot; from where data &lt;= &quot;2021-12-21&quot; user group by date having count(&quot;date&quot;) &gt; 10</p><p>分组查询中，经常会用到聚合函数，常见的聚合函数有以下几种：</p><ul><li>count(字段/*)：根据某个字段统计数量</li><li>max(字段)：某个字段为表中最大值的数据</li><li>min(字段)：某个字段为表中最小值的数据</li><li>avg(字段)：计算某个字段的平均值</li><li>sum(字段)：计算某个字段之和</li></ul><p>where与having的区别：</p><ul><li>where是在分组之前使用，是对分组前的数据进行过滤，符合条件的才参与分组；having是对分组后的数据进行过滤</li><li>where不能对聚合函数进行判断，having可以</li></ul><h3 id="排序查询" tabindex="-1"><a class="header-anchor" href="#排序查询" aria-hidden="true">#</a> 排序查询</h3><p>排序查询，需要使用order by，支持两种排序方式，asc升序，desc降序，如果不写，默认为asc</p><p>基本语法：select 字段列表 from 表名 [where 条件列表] [group by 分组字段名] [having 分组后过滤条件] order by 排序字段1 [asc/desc],排序字段2 [asc/desc]...</p><h3 id="分页查询" tabindex="-1"><a class="header-anchor" href="#分页查询" aria-hidden="true">#</a> 分页查询</h3><p>分页查询中，需要使用limit，数据开始索引从0开始</p><p>基本语法为：select 字段列表 from 表名 [where 筛选条件] limit 数据开始索引，单页数量</p><h2 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型" aria-hidden="true">#</a> 数据类型</h2><h3 id="数值型" tabindex="-1"><a class="header-anchor" href="#数值型" aria-hidden="true">#</a> 数值型</h3><ol><li>整数类型</li></ol><table><thead><tr><th>类型</th><th>大小</th><th>有符号范围</th><th>无符号范围</th><th>描述</th></tr></thead><tbody><tr><td>TINYINT</td><td>1byte</td><td>(-128，127)</td><td>(0，255)</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2bytes</td><td>(-32768，32767)</td><td>(0，65535)</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3bytes</td><td>(-8388608，8388607)</td><td>(0，16777215)</td><td>大整数值</td></tr><tr><td>INT/INTEGER</td><td>4bytes</td><td>(-2147483648，2147483647)</td><td>(0，4294967295)</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8bytes</td><td>(-2^63，2^63-1)</td><td>(0，2^64-1)</td><td>极大整数值</td></tr></tbody></table><ol start="2"><li>浮点数类型</li></ol><table><thead><tr><th>类型</th><th>大小</th><th>有符号范围</th><th>无符号范围</th><th>描述</th></tr></thead><tbody><tr><td>FLOAT</td><td>4bytes</td><td>(-3.402823466 E+38，3.402823466351 E+38)</td><td>0 和 (1.175494351 E-38，3.402823466 E+38)</td><td>单精度浮点数值</td></tr><tr><td>DOUBLE</td><td>8bytes</td><td>(-1.7976931348623157 E+308，1.7976931348623157 E+308)</td><td>0 和 (2.2250738585072014 E-308，1.7976931348623157 E+308)</td><td>双精度浮点数值</td></tr></tbody></table><ol start="3"><li>精确数值类型</li></ol><table><thead><tr><th>类型</th><th>大小</th><th>有符号范围</th><th>无符号范围</th><th>描述</th></tr></thead><tbody><tr><td>DECIMAL</td><td>-</td><td>依赖于M(精度)和D(标度)的值</td><td>依赖于M(精度)和D(标度)的值</td><td>小数值(精确定点数)</td></tr></tbody></table><p>修饰符</p><ul><li>unsigned：表示为无符号</li><li>auto_increment：表示自增</li></ul><h3 id="字符串" tabindex="-1"><a class="header-anchor" href="#字符串" aria-hidden="true">#</a> 字符串</h3><table><thead><tr><th>类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255 bytes</td><td>定长字符串(需要指定长度)</td></tr><tr><td>VARCHAR</td><td>0-65535 bytes</td><td>变长字符串(需要指定长度)</td></tr><tr><td>TINYBLOB</td><td>0-255 bytes</td><td>不超过255个字符的二进制数据</td></tr><tr><td>TINYTEXT</td><td>0-255 bytes</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535 bytes</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 bytes</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 bytes</td><td>极大文本数据</td></tr></tbody></table><p>char 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性能会更高些。</p><h3 id="日期类型" tabindex="-1"><a class="header-anchor" href="#日期类型" aria-hidden="true">#</a> 日期类型</h3><table><thead><tr><th>类型</th><th>大小</th><th>范围</th><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>1000-01-01 至 9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>-838:59:59 至 838:59:59</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td>1901 至 2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00 至 9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:01 至 2038-01-19 03:14:07</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table><h2 id="多表设计" tabindex="-1"><a class="header-anchor" href="#多表设计" aria-hidden="true">#</a> 多表设计</h2><h3 id="表间关系" tabindex="-1"><a class="header-anchor" href="#表间关系" aria-hidden="true">#</a> 表间关系</h3><ol><li>一对多</li></ol><p>一对多主要通过外键约束来进行实现，外键约束是指一个表中的数据必须与另一个表中的数据一致。</p><p>基本语法如下：</p><ul><li><p>创建表时添加外键约束：create table 表名称 (字段名称 字段类型 字段约束,... CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名称 (主键字段))</p></li><li><p>添加外键约束：alter table 表名称 add constraint 外键名称 foreign key (外键字段) references 主表名称 (主键字段)</p></li></ul><p>物理外键：</p><p>使用foreign key指定的外键是物理外键，使用物理外键有个以下几个缺点</p><ul><li>影响增删改的效率，每次操作都需要检查外键关系</li><li>不适用于分布式、集群的情况</li><li>容易引发数据库死锁问题，影响性能</li></ul><p>逻辑外键：</p><p>在逻辑层中，解决外键关联</p><ol start="2"><li>一对一</li></ol><p>一对一常用于对复杂单表的拆分，将一个单表拆分为多个小的表，</p><ol start="3"><li>多对多</li></ol><p>多对多的实现通过建立第三张表成为中间表，中间表记录两个外键，分别对应另外两张表</p><h3 id="多表查询" tabindex="-1"><a class="header-anchor" href="#多表查询" aria-hidden="true">#</a> 多表查询</h3><p>查询多张表中的数据</p><p>内连接查询：查询两个表的交集</p><p>内连接查询有两种语法，分别是隐式内连接和显式内连接</p><ul><li><p>隐式内连接语法：select * from 表1,表2 where 表1.字段=表2.字段;</p></li><li><p>显示内连接语法：select * from 表1 [inner] join 表2 on 表1.字段=表2.字段;</p></li><li><p>左外连接查询：查询左表所有的数据，包含于右表交集的部分，语法如下：</p></li></ul><p>select * from 表1 left [outer] join 表2 on 表1.字段=表2.字段;</p><ul><li>右外连接查询：查询右表所有的数据，包含于左表交集的部分，语法如下：</li></ul><p>select * from 表1 right [outer] join 表2 on 表1.字段=表2.字段;</p><ul><li>标量子查询：子查询返回的是一个单行单列的值，比如日期、数值、字符串、日期等，语法如下:</li></ul><p>select * from 表名 where 字段名 [=|!=|&gt;|&gt;=|&lt;|&lt;=] (select 字段名 from 表名 where 条件);</p><ul><li>列子查询：子查询返回的是多行单列的值，子查询的结果常用于条件满足结果值其中一个的情况，语法如下：</li></ul><p>select * from 表名 where 字段名 [in|not in] (select 字段名 from 表名 where 条件)</p><ul><li>行子查询：子查询返回的结果是一行多列的值，子查询的结果常用于条件满足多个字段结果的情况，语法如下：</li></ul><p>select * from 表名 where (字段1,字段2...) [=|!=] (select 字段1,字段2... from 表名 where 条件)</p><ul><li>表子查询：子查询返回的结果是一个多行多列的值，子查询的结果常用于作为一张新的表，语法如下：</li></ul><p>select e.* from (select* from 表名 where 条件) as e [inner join|left join|right join] 表名 on e.id=表名.id</p><h3 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h3><p>事务是一系列操作的集合，是数据库操作的一个单位，这些操作要么同时成功，要么同时失败</p><p>事务的控制包括开启事务、提交事务、回滚事务</p><p>开启事务 start transaction / begin：事务的开头</p><p>提交事务 commit：事务提交给数据库软件执行</p><p>回滚事务 rollback：当事务失败后取消事务的所有操作</p><p>事务的特性：</p><ul><li>原子性：事务是不可分割的最小单元，要么全部成功，要么全部失败</li><li>一致性：事务完成后，所有数据必须保持一致性</li><li>隔离性：事务的执行，是在不受外部并发的影响下在独立的环境中执行</li><li>持久性：事务一旦完成或者回滚，对数据的改变就是永久的</li></ul><h3 id="索引" tabindex="-1"><a class="header-anchor" href="#索引" aria-hidden="true">#</a> 索引</h3><p>索引是一种帮助高效查询数据的数据结构，但是更新、删除、新增的效率不高，同时索引会占用额外的硬盘空间</p><p>创建索引：create [unique] index 索引名称 on 表名(字段名,...)</p><p>查询索引：show index from 表名</p><p>删除索引：drop index 索引名 on 表名</p><p>建表时，如果之定义一个字段为主键，那么数据库会使用这个字段创建<code>主键索引</code>，如果指定了字段对应的值为唯一值，那么也会创建对应的<code>唯一索引</code></p>',97),r=[a];function h(o,s){return e(),d("div",null,r)}const c=t(i,[["render",h],["__file","mysql-base.html.vue"]]);export{c as default};
