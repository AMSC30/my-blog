# 面向对象

## 类

类是对一类事物的抽象表示，由属性(成员变量)和行为(成员方法)组成

测试类：带main方法的类，主要用于运行代码

实体类：无main方法的类，主要用来表示对象

抽象类：抽象类不能实例化，只能被继承，抽象类中可以有抽象方法，抽象方法没有方法体，抽象方法必须被继承类实现

抽象类和实体类区别：抽象类不能实例化，只能被继承

## 抽象

抽象是指不具体实现，抽象方法不能有方法体并且一定要在抽象类中，抽象类中可以有抽象方法，也可以没有抽象方法

抽象类不能实例化，只能被继承；非抽象子类的继承必须重写父类的所有抽象方法

抽象类可以看做是一个事物的标准模板，属于这个父类的子类，所有抽象方法都必须得到具体实现

定义一个抽象类：abstract class 类名{}

定义抽象方法：abstract 返回值类型 方法名(参数列表);

## 封装

将实现的细节封装起来，对外提供接口

使用private修饰的成员变量，外部类不能直接访问，只能通过getter和setter方法访问

如果成员变量和局部变量重名时，优先访问局部变量，也就是就近原则，使用this关键字可以访问成员变量，this代表调用this所在方法的对象

构造方法：构造方法名与类型相同，没有返回值，并且不适用void，分为有参构造和无参构造

定义一个类时，jvm内部默认会有一个无参构造方法

```java
public class Person {
    public Person(){
        System.out.println('我是无参构造方法');
    }
}
```

有参构造方法可以在new的时候为对象的成员变量进行赋值，当定义了一个有参构造方法后，jvm提供的默认无参构造方法会被覆盖，我们可以自己定义一个无参构造方法，此时实例化对象时既可以传参也可以不传参

```java
public class Person {
    String name;
    public Person(){
        System.out.println('我是无参构造方法');
    }
    public Person(String name){
        this.name = name;
    }
}
```

### javabean

javabean是一种编码规范，类必须是具体的和公共的，不能是抽象类；类中包含无参构造和有参构造方法；成员的变量私有化，提供getter和setter方法

### static

静态关键字，用于修饰成员变量和成员方法，通过static修饰的变量和方法属于类的属性和方法，加载时随着类的加载而加载

使用包含静态成员的类创建出来的所有对象共享静态成员

静态成员访问特点：

1. 静态成员访问非静态成员：需要通过new创建对象后调用

2. 静态成员访问静态成员：本类可以直接访问，也可以通过类名访问，他类需要通过类名访问

3. 非静态成员访问非静态成员：本类可以直接访问，他类需要通过new创建对象访问

4. 非静态成员访问静态成员：本类可以直接访问，他类需要通过类名访问

### final关键字

final修饰符用于修饰类，类中的成员变量、成员方法、局部变量和对象

1. 修饰类

使用final修饰符修饰类时，类不能被继承，类中的成员不能被重写

2. 修饰方法

使用final修饰符修饰父类方法时，子类继承父类不能重写父类被final修饰的方式；final修饰符不能修饰构造方法和静态方法，并且不能与abstract同时使用

3. 修饰成员变量

成员变量在定义类的时候需要手动赋值，包括在构造函数中也不能对其赋值

4. 修饰局部变量

使用final修饰符修饰局部变量时，不能对局部变量进行赋值，如果局部变量是引用类型，可以修改引用类型中的值

### 访问修饰符

权限修饰符用于修饰类和类中的成员，只有default、abstract和public可以用于修饰类，不使用任何修饰符时，表示default(友好型)

1. public：如果一个类或者类的成员被public访问控制符修饰，那么这个类或者类的成员能被所有的类访问，不管访问类与被访问类是否在同一个包中
2. protected：如果一个类的成员被protected访问控制符修饰，那么这个成员既能被同一包下的其他类访问，也能被不同包下该类的子类访问
3. default：如果一个类或者类的成员不使用任何访问控制符修饰，则称它为默认访问控制级别，这个类或者类的成员只能被本包中的其他类访问
4. private：如果类的成员被private访问控制符来修饰，则这个成员只能被该类的其他成员访问，其他类无法直接访问。类的良好封装就是通过private关键字来实现的；使用private
   修饰的方法不能被子类重写

表格总结：

| 形式 | public | protected | default | private |
|---|:---:|---:|:---:|---:|
| 同包同类 | yes | yes |yes | yes |
| 同包不同类 | yes | yes |yes | no |
| 不同包继承 | yes | yes |no | no |
| 不同包非继承 | yes | no |no | no |

## 继承

继承是子类可以继承父类中的属性和方法，是java中实现复用的重要手段，在java中继承是单一的，即一个子类只能有一个父类，但是一个父类可以有多个子类

继承通过extends实现一个子类继承一个父类，子类有自己的构造方法，可以`继承`父类的私有和非私有成员，但是不能继承父类的构造方法，也不能`使用`父类中的私有成员

java中所有的类都继承自Object类，所以除了Object类，所有的类都有一个父类

### 成员变量访问

当子类和父类有相同的成员变量时，子类会覆盖父类成员变量，此时使用子类对象访问成员变量时，会优先使用子类成员变量，如果使用父类对象访问成员变量，则优先使用父类成员变量

当子类和父类的成员变量不重名时，如果等号左边是父类类型，只能调用父类中的成员变量；如果等号左边是子类类型，优先调用子类成员变量，子类没有，再调用父类的非私有成员变量

### 成员方法访问

在继承中，访问成员方法，看使用new时使用的哪个类，就优先调用哪个类的成员方法

如果是父类，则只能调用父类中的成员方法；如果是子类，则优先调用子类中的成员方法，子类没有，再调用父类的非私有成员方法

> 总结：访问方法和变量，都是子类可以访问父类非私有，父类不能访问子类;变量通过=左边确定类型，方法通过new确定类型

### 方法重写

在继承关系中，当父类和子类拥有相同的方法名和参数列表时，此时父类的方法被子类重写，方法的调用符合继承中成员方法的访问特点

- 子类重写父类方法后，访问权限必须大于等于父类
- 父类中的构造方法、私有方法(private)、静态方法(static)不能被重写
- 子类方法抛出的异常应该是父类方法抛出异常的子类类型

### Super

Super代表父类的引用，可以调用父类中的成员

1. 调用父类构造函数：在子类的构造函数中第一行调用Super()或者Super(参数)
2. 调用父类的成员变量：在子类中成员方法中使用Super.a
3. 调用父类的成员方法：在子类中成员方法中使用Super.a()

### this

表示调用this所在方法的调用对象

1. 用与区分成员变量和局部变量
2. 调用对象的成员

除了指向对象，this还可以单独调用，即this()，这种使用方式可以调用当前对象的构造方法

## 接口

接口是一种抽象的类型，不能实例化对象，只能通过implements关键字实现，一个类可以继承一个或多个接口；一个接口可以继承一个或多个接口

定义接口：public interface 接口名{}

实现接口:public class 类名 implements 接口名{}

接口中的成员变量默认是public static final的，如果不加public static，编译器会自动为我们加上，所以在接口中，只能使用静态变量，并且必须初始化，按照规范，变量名最好使用大写。接口中的成员方法默认是public abstract的，如果不加public abstract，编译器会自动加上

> jdk8以后新增了默认方法和静态方法，jdk9以后新增了私有方法

一个类实现的多个接口有相同名称和参数的抽象方法，实现类需要且只需要重写一次；

一个类实现的多个接口有相同名称和参数的默认方法，实现类需要且必须重写该方法

### 抽象类与接口

接口是抽象的，抽象类是具体的，抽象类可以有抽象方法，抽象类也可以有具体方法

一个接口可以继承多个接口，如public interface 接口名 extends 接口名1,接口名2{}

一个实现类可以实现多个接口，如public class 类名 implements 接口名1,接口名2{}

当多个接口有相同的抽象方法且参数相同时，实现类只需要重写一次即可

当多个接口有相同的默认方法且参数相同时，实现类必须重写一次默认方法

## 多态

多态是指在面向对象编程中，同一个类的对象在不同情况下表现出来的不同行为和状态。 多态的目的是为了提高代码的灵活性和可扩展性，使得代码更容易维护和扩展。

多态的前提：

1. 必须和一个类有继承关系或者和一个接口有实现关系
2. 必须有方法的重写，多态的意义主要就是方法的重写
3. 必须有父类引用指向子类对象

多态的实现：父类可以接收子类对象

### 转型

多态中的父类引用变量指向子类对象，这种方式是一种向上转型，只能使用父类已声明的方法，但方法如果被重写会执行子类的方法，如果方法未被重写那么将执行父类的方法,例如：

```java
    Animal animal = new Dog();
```

向下转型是指，将父类对象转为子类类型，在书写上父类对象需要加括号()强制转换为子类类型。但父类引用变量实际引用必须是子类对象才能成功转型，就可以调用一些子类特有而父类没有的方法 例如：

```java
    Animal animal = new Dog();
    Dog dog = (Dog) animal;
```

转型过程中，可能会转成错误类型，这时会抛出ClassCastException异常，通过instanceof关键字判断对象类型，然后再进行转型。
