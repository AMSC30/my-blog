# 事务

事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败

## 事务简介

事务是一系列操作的集合，是数据库操作的一个单位，这些操作要么同时成功，要么同时失败

事务的控制包括开启事务、提交事务、回滚事务

## 事务操作

开启事务 start transaction / begin：事务的开头

提交事务 commit：事务提交给数据库软件执行

回滚事务 rollback：当事务失败后取消事务的所有操作

## 事务特性

- 原子性 Atomicity：事务是不可分割的最小单元，要么全部成功，要么全部失败
- 一致性 Consistency：事务完成后，所有数据必须保持一致性
- 隔离性 Isolation：事务的执行，是在不受外部并发的影响下在独立的环境中执行
- 持久性 Durability：事务一旦完成或者回滚，对数据的改变就是永久的

## 事务并发问题

### 脏读

一个事务读到另一个事务未提交的数据

### 不可重复读

一个事务先后读取同一条记录，但两次读取的数据不同

### 幻读

一个事务按照条件查询某条记录时，没有查询到，但是在插入的时候，又发现这条数据存在

## 事务原理

我们研究事务的原理，就是研究MySQL的InnoDB引擎是如何保证事务的这四大特性的

而对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。 而隔离性是通过数据库的锁，加上MVCC来保证的

### MySQL 驱动

MySQL 驱动在底层帮我们做了对数据库的连接，只有建立了连接了，才能够有后面的交互

java 系统在通过 MySQL 驱动和 MySQL 数据库连接的时候是基于 TCP/IP 协议的，所以如果每个请求都是新建连接和销毁连接，多线程请求的时候频繁的创建和销毁连接显然是不合理的，这样势必会造成不必要的浪费和性能的下降

数据库连接池：维护一定的连接数，方便系统获取连接，使用就去池子中获取，用完放回去就可以了。常见的数据库连接池有 Druid、C3P0、DBCP

MySQL 的架构体系中也已经提供了这样的一个池子，也是数据库连池。双方都是通过数据库连接池来管理各个连接的，这样一方面线程之前不需要是争抢连接，更重要的是不需要反复的创建的销毁连接

MySQL语句执行流程如下：

![sql执行流程](../images/db-mysql-sql-8.png)

### 存储引擎

真正执行 SQL 的动作是在存储引擎中完成的。数据是被存放在内存或者是磁盘中的，执行器最终根据一系列的执行计划去调用存储引擎的接口去完成 SQL 的执行

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式，存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型

查看所有支持的引擎使用命令`show engines`

#### 缓冲池

SQL 语句对应的数据要么是在内存中，要么是在磁盘中，如果直接在磁盘中操作，那这样的随机IO读写的速度肯定让人无法接受的，所以每次在执行 SQL 的时候都会将其数据加载到内存中，这块内存就是 InnoDB 中一个非常重要的组件：缓冲池 `Buffer Pool`

Buffer Pool （缓冲池）是 InnoDB 存储引擎中非常重要的内存结构，顾名思义，缓冲池其实就是类似 Redis 一样的作用，起到一个缓存的作用，因为我们都知道 MySQL 的数据最终是存储在磁盘中的，如果没有这个 Buffer Pool 那么我们每次的数据库请求都会磁盘中查找，这样必然会存在 IO 操作，这肯定是无法接受的。但是有了 Buffer Pool 就是我们第一次在查询的时候会将查询的结果存到 Buffer Pool 中，这样后面再有请求的时候就会先从缓冲池中去查询，如果没有再去磁盘中查找，然后在放到 Buffer Pool 中

有了缓冲池，存储引擎的执行顺序：

1. InnoDB存储引擎会在缓冲池中查找 id=1 的这条数据是否存在
2. 发现不存在，那么就会去磁盘中加载，并将其存放在缓冲池中
3. 该条记录会被加上一个独占锁

### undo log

回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和MVCC(多版本并发控制），是 InnoDB 特有的，他是存储引擎级别的，不是MySQL级别的

Innodb 存储引擎的最大特点就是支持事务，如果本次更新失败，也就是事务提交失败，那么该事务中的所有的操作都必须回滚到执行前的样子，也就是说当事务失败的时候，也不会对原始数据有影响

在准备更新一条语句的时候，该条语句已经被加载到 Buffer pool 中了，实际上这里还有这样的操作，就是在将该条语句加载到 Buffer Pool 中的时候同时会往 undo 日志文件中插入一条日志，也就是将 id=1 的这条记录的原来的值记录下来

它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的
update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚

Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC

Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment回滚段中，内部包含1024个undo log segment

### redo log

redo日志(重做日志)是 InnoDB 特有的，他是存储引擎级别的，不是 MySQL 级别的

该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用

有了redo log之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redo log就没有作用了，就可以删除了，所以存在的两个redo log文件是循环写的

> 那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢 ?
>
>因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 WAL（Write-Ahead Logging）

### bin日志

binlog 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层

不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志

binlog 会记录所有涉及更新数据的逻辑操作，并且是顺序写，可以用来同步数据，保证数据一致性

binlog 日志有三种格式，可以通过binlog_format参数指定

1. STATEMENT

默认值，记录每条语句的完整内容，同步数据时，会执行记录的SQL语句，但是有个问题，update_time=now()这里会获取当前系统时间，直接执行会导致与原库的数据不一致

2. row

记录的内容不再是简单的SQL语句了，还包含操作的具体数据

3. mixed

记录的内容是前两者的混合，MySQL 会判断这条SQL语句是否可能引起数据不一致，如果是，就用row格式，否则就用statement格式
