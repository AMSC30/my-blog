# MySQL

## 数据模型

关系型数据库

建立在关系型数据模型上，由多张二维表相互连接组成的数据库

sql语句通用语法

- sql语句可以单行或者多行书写，以分号结尾
- sql语句可以使用空格或缩进来增强sql语句的可读性
- sql语句可以不区分大小写，但建议使用大写
- sql语句可以注释，使用#作为单行注释，使用/**/作为多行注释，在mysql中还可以使用#来进行单行注释

## sql语句分类

### DDL语句

数据库定义语言，用于创建和删除数据库、表、字段

- 查询所有数据库: show databases;
- 查询当前使用的数据库：select database();
- 创建数据库：create database [if not exists] 数据库名;
- 删除数据库：drop database [if exists] 数据库名;
- 使用数据库：use 数据库名;
- 创建表：create table  表名(字段1  字段1类型 [约束]  [comment  字段1注释 ],字段2  字段2类型 [约束]  [comment  字段2注释 ],......字段n  字段n类型 [约束]  [comment  字段n注释 ]
) [ comment  表注释 ] ;
- 删除表：drop table [if exists] 表名;
- 修改表名: rename table 表名 to 新表名;
- 查询表结构：desc 表名;
- 查询所有的表: show tables;
- 查询建表语句：show create table 表名;
- 添加字段：alter table 表名 add 字段名称 字段类型(长度) [comment 注释]  [约束]
- 修改字段类型：alter table 表名 modify 字段名称 字段类型(长度) [comment 注释]  [约束]
- 修改字段名称和类型：alter table 表名 change 旧名称字段 新名称字段 字段类型(长度) [comment 注释]  [约束]
- 删除字段：alter table 表名 drop column 字段名称;

> 字段约束用于保证表中字段数据的正确性和完整性，是作用于字段的规则
>
>1. 非空约束 not null：存储在表中的字段数据不能为null
>2. 唯一约束 unique：存储在表中的字段数据必须唯一，不能重复
>3. 主键约束 primary key：存储在表中的字段数据必须唯一且不能重复，并且不能为null
>4. 默认约束 default：如果没有指定字段的值，则使用默认值
>5. 外键约束 foreign key：让两张表建立联系

### DML语句

数据库操作语言，用于对数据的增删改

- 添加表指定字段数据：insert into 表名(字段1,字段2,字段3) values[值1,值2,值3](,(值1,值2,值3))
- 添加表所有字段数据：insert into 表名 values(值1,值2,值3,...),(值1,值2,值3,...)
- 修改表指定字段数据：update 表名 set 字段1=值1,字段2=值2,字段3=值3 [where 条件]
- 删除表指定字段数据：delete from 表名 [where 条件]

### DQL

#### 基本查询

1. 查询所有字段：select * from 表名
2. 查询多个字段：select 字段1,字段2[,...] from 表名
3. 查询后设置别名 select 字段1 [as] 字段1别名,字段2 from 表名
4. 查询后去除重复值 select distinct 字段列表 from 表名

#### 条件查询

基本语句：select 字段列表 from 表名 where 条件列表

运算符

条件列表中的条件运算符主要分为比较运算符和逻辑运算符

比较运算符：

- \>, >=, \<, \<=, =, !=：做相等和大小判断
- between A and B：在A与B的这个范围之内
- in (...)：值为in后面的列表之一
- like 占位符：模糊匹配，_匹配单个字符，%匹配任意个字符，包括0个
- is null：值为null，不能使用`=null`
- is not null：值不为null

逻辑运算符：

- and或者&&：逻辑与，同时满足
- or或者||；逻辑或，满足其中一个
- not或者!：逻辑非，不满足条件

#### 分组查询

分组查询语法：select 字段列表 from 表名 [where 条件列表] group by 分组字段名 [having 分组后过滤条件]

示例：select gender,count("date") as "date_count" from where data <= "2021-12-21" user group by date having count("date") > 10

分组查询中，经常会用到聚合函数，常见的聚合函数有以下几种：

- count(字段/*)：根据某个字段统计数量
- max(字段)：某个字段为表中最大值的数据
- min(字段)：某个字段为表中最小值的数据
- avg(字段)：计算某个字段的平均值
- sum(字段)：计算某个字段之和

where与having的区别：

- where是在分组之前使用，是对分组前的数据进行过滤，符合条件的才参与分组；having是对分组后的数据进行过滤
- where不能对聚合函数进行判断，having可以

#### 排序查询

排序查询，需要使用order by，支持两种排序方式，asc升序，desc降序，如果不写，默认为asc

基本语法：select 字段列表 from 表名 [where 条件列表] [group by 分组字段名] [having 分组后过滤条件] order by 排序字段1 [asc/desc],排序字段2 [asc/desc]...

#### 分页查询

分页查询中，需要使用limit，数据开始索引从0开始

基本语法为：select 字段列表 from 表名 [where 筛选条件] limit 数据开始索引，单页数量

### DCL语句

数据库控制语言，用于操作数据库的用户及权限

## 数据类型

### 数值型

#### 1. 整数类型

| 类型 | 大小 | 有符号范围 | 无符号范围 | 描述 |
|------|------|------------|------------|------|
| TINYINT | 1byte | (-128，127) | (0，255) | 小整数值 |
| SMALLINT | 2bytes | (-32768，32767) | (0，65535) | 大整数值 |
| MEDIUMINT | 3bytes | (-8388608，8388607) | (0，16777215) | 大整数值 |
| INT/INTEGER | 4bytes | (-2147483648，2147483647) | (0，4294967295) | 大整数值 |
| BIGINT | 8bytes | (-2^63，2^63-1) | (0，2^64-1) | 极大整数值 |

#### 2. 浮点数类型

| 类型 | 大小 | 有符号范围 | 无符号范围 | 描述 |
|------|------|------------|------------|------|
| FLOAT | 4bytes | (-3.402823466 E+38，3.402823466351 E+38) | 0 和 (1.175494351 E-38，3.402823466 E+38) | 单精度浮点数值 |
| DOUBLE | 8bytes | (-1.7976931348623157 E+308，1.7976931348623157 E+308) | 0 和 (2.2250738585072014 E-308，1.7976931348623157 E+308) | 双精度浮点数值 |

#### 3. 精确数值类型

| 类型 | 大小 | 有符号范围 | 无符号范围 | 描述 |
|------|------|------------|------------|------|
| DECIMAL | - | 依赖于M(精度)和D(标度)的值 | 依赖于M(精度)和D(标度)的值 | 小数值(精确定点数) |

修饰符

- unsigned：表示为无符号
- auto_increment：表示自增

### 字符串

| 类型       | 大小                  | 描述                         |
| ---------- | --------------------- | ---------------------------- |
| CHAR       | 0-255 bytes           | 定长字符串(需要指定长度)     |
| VARCHAR    | 0-65535 bytes         | 变长字符串(需要指定长度)     |
| TINYBLOB   | 0-255 bytes           | 不超过255个字符的二进制数据  |
| TINYTEXT   | 0-255 bytes           | 短文本字符串                 |
| BLOB       | 0-65 535 bytes        | 二进制形式的长文本数据       |
| TEXT       | 0-65 535 bytes        | 长文本数据                   |
| MEDIUMBLOB | 0-16 777 215 bytes    | 二进制形式的中等长度文本数据 |
| MEDIUMTEXT | 0-16 777 215 bytes    | 中等长度文本数据             |
| LONGBLOB   | 0-4 294 967 295 bytes | 二进制形式的极大文本数据     |
| LONGTEXT   | 0-4 294 967 295 bytes | 极大文本数据                 |

char 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性能会更高些。

### 日期类型

| 类型      | 大小 | 范围                                       | 格式                | 描述                     |
| --------- | ---- | ------------------------------------------ | ------------------- | ------------------------ |
| DATE      | 3    | 1000-01-01 至  9999-12-31                  | YYYY-MM-DD          | 日期值                   |
| TIME      | 3    | -838:59:59 至  838:59:59                   | HH:MM:SS            | 时间值或持续时间         |
| YEAR      | 1    | 1901 至 2155                               | YYYY                | 年份值                   |
| DATETIME  | 8    | 1000-01-01 00:00:00 至 9999-12-31 23:59:59 | YYYY-MM-DD HH:MM:SS | 混合日期和时间值         |
| TIMESTAMP | 4    | 1970-01-01 00:00:01 至 2038-01-19 03:14:07 | YYYY-MM-DD HH:MM:SS | 混合日期和时间值，时间戳 |

## 多表设计

### 表间关系

1. 一对多

一对多主要通过外键约束来进行实现，外键约束是指一个表中的数据必须与另一个表中的数据一致。

基本语法如下：

- 创建表时添加外键约束：create table 表名称 (字段名称 字段类型 字段约束,...  CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名称 (主键字段))

- 添加外键约束：alter table 表名称 add constraint 外键名称 foreign key (外键字段) references 主表名称 (主键字段)

物理外键：

使用foreign key指定的外键是物理外键，使用物理外键有个以下几个缺点

- 影响增删改的效率，每次操作都需要检查外键关系
- 不适用于分布式、集群的情况
- 容易引发数据库死锁问题，影响性能

逻辑外键：

在逻辑层中，解决外键关联

2. 一对一

一对一常用于对复杂单表的拆分，将一个单表拆分为多个小的表，

3. 多对多

多对多的实现通过建立第三张表成为中间表，中间表记录两个外键，分别对应另外两张表

### 多表查询

查询多张表中的数据

内连接查询：查询两个表的交集

内连接查询有两种语法，分别是隐式内连接和显式内连接

- 隐式内连接语法：select * from 表1,表2 where 表1.字段=表2.字段;

- 显示内连接语法：select * from 表1 [inner] join 表2 on 表1.字段=表2.字段;

- 左外连接查询：查询左表所有的数据，包含于右表交集的部分，语法如下：

select * from 表1 left [outer] join 表2 on 表1.字段=表2.字段;

- 右外连接查询：查询右表所有的数据，包含于左表交集的部分，语法如下：

select * from 表1 right [outer] join 表2 on 表1.字段=表2.字段;

- 标量子查询：子查询返回的是一个单行单列的值，比如日期、数值、字符串、日期等，语法如下:

select * from 表名 where 字段名 [=|!=|>|>=|<|<=] (select 字段名 from 表名 where 条件);

- 列子查询：子查询返回的是多行单列的值，子查询的结果常用于条件满足结果值其中一个的情况，语法如下：

select * from 表名 where 字段名 [in|not in] (select 字段名 from 表名 where 条件)

- 行子查询：子查询返回的结果是一行多列的值，子查询的结果常用于条件满足多个字段结果的情况，语法如下：

select * from 表名 where (字段1,字段2...) [=|!=] (select 字段1,字段2... from 表名 where 条件)

- 表子查询：子查询返回的结果是一个多行多列的值，子查询的结果常用于作为一张新的表，语法如下：

select e.\* from (select* from 表名 where 条件) as e [inner join|left join|right join] 表名 on e.id=表名.id

### 事务

事务是一系列操作的集合，是数据库操作的一个单位，这些操作要么同时成功，要么同时失败

事务的控制包括开启事务、提交事务、回滚事务

开启事务 start transaction / begin：事务的开头

提交事务 commit：事务提交给数据库软件执行

回滚事务 rollback：当事务失败后取消事务的所有操作

事务的特性：

- 原子性：事务是不可分割的最小单元，要么全部成功，要么全部失败
- 一致性：事务完成后，所有数据必须保持一致性
- 隔离性：事务的执行，是在不受外部并发的影响下在独立的环境中执行
- 持久性：事务一旦完成或者回滚，对数据的改变就是永久的

### 索引

索引是一种帮助高效查询数据的数据结构，但是更新、删除、新增的效率不高，同时索引会占用额外的硬盘空间

创建索引：create [unique] index 索引名称 on 表名(字段名,...)

查询索引：show index from 表名

删除索引：drop index 索引名 on 表名

建表时，如果之定义一个字段为主键，那么数据库会使用这个字段创建`主键索引`，如果指定了字段对应的值为唯一值，那么也会创建对应的`唯一索引`
