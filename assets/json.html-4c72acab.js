import{_ as t,p as o,q as u,Y as e}from"./framework-e1bed10d.js";const q={},p=e('<h2 id="json" tabindex="-1"><a class="header-anchor" href="#json" aria-hidden="true">#</a> JSON</h2><p>JSON 格式 JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式，2001年由 Douglas Crockford 提出，目的是取代繁琐笨重的 XML 格式。 相比 XML 格式，JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。所以，JSON 迅速被接受，已经成为各大网站交换数据的标准格式，并被写入标准。</p><p>JSON 对值的类型和格式有严格的规定。</p><ol><li>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</li><li>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。</li><li>字符串必须使用双引号表示，不能使用单引号。</li><li>对象的键名必须放在双引号里面。</li><li>数组或对象最后一个成员的后面，不能加逗号。</li></ol><p>以下都是合法的 JSON。 [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;，null, 1, true]</p><p>{ &quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3 }</p><p>{&quot;names&quot;: [&quot;张三&quot;, &quot;李四&quot;] }</p><p>[ { &quot;name&quot;: &quot;张三&quot;}, {&quot;name&quot;: &quot;李四&quot;} ]</p><p>以下都是不合法的 JSON。 { name: &quot;张三&quot;, &#39;age&#39;: 32 } // 属性名必须使用双引号</p><p>[32, 64, 128, 0xFFF] // 不能使用十六进制值</p><p>{ &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: undefined } // 不能使用 undefined</p><p>{ &quot;name&quot;: &quot;张三&quot;, &quot;birthday&quot;: new Date(&#39;Fri, 26 Aug 2011 07:13:10 GMT&#39;), &quot;getName&quot;: function () { return this.name; } } // 属性值不能使用函数和日期对象</p><p>注意，null、空数组和空对象都是合法的 JSON 值。 JSON.stringify() JSON.stringify()方法用于将一个值(符合JSON格式的值)转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被JSON.parse()方法还原。 JSON.stringify(&#39;abc&#39;) // &#39;&quot;abc&quot;&#39; JSON.stringify(1) // &quot;1&quot; JSON.stringify(false) // &quot;false&quot; JSON.stringify([]) // &quot;[]&quot; JSON.stringify({}) // &quot;{}&quot;</p><p>JSON.stringify([1, &quot;false&quot;, false]) // &#39;[1,&quot;false&quot;,false]&#39;</p><p>JSON.stringify({ name: &quot;张三&quot; }) // &#39;{&quot;name&quot;:&quot;张三&quot;}&#39;</p><p>对于原始类型的字符串，转换结果会带双引号,因为将来还原的时候，内层双引号可以让 JavaScript 引擎知道，这是一个字符串，而不是其他类型的值 JSON.stringify(&#39;foo&#39;) === &quot;foo&quot; // false JSON.stringify(&#39;foo&#39;) === &quot;&quot;foo&quot;&quot; // true</p><p>如果对象的属性是undefined、函数或 XML 对象，该属性会被JSON.stringify()过滤。 var obj = { a: undefined, b: function () {} };</p><p>JSON.stringify(obj) // &quot;{}&quot;</p><p>如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null。 var arr = [undefined, function () {}]; JSON.stringify(arr) // &quot;[null,null]&quot;</p><p>如果是日期对象，将会转成字符串，日期对象有自己的toJSON属性 如果是正则对象，将会转成空对象</p><p>JSON.stringify()方法会忽略对象的不可遍历的属性。 var obj = {}; Object.defineProperties(obj, { &#39;foo&#39;: { value: 1, enumerable: true }, &#39;bar&#39;: { value: 2, enumerable: false } });</p><p>JSON.stringify(obj); // &quot;{&quot;foo&quot;:1}&quot;</p><p>replacer JSON.stringify()方法还可以接受一个数组，作为第二个参数，指定参数对象的哪些属性需要转成字符串。 var obj = { &#39;prop1&#39;: &#39;value1&#39;, &#39;prop2&#39;: &#39;value2&#39;, &#39;prop3&#39;: &#39;value3&#39; };</p><p>var selectedProperties = [&#39;prop1&#39;, &#39;prop2&#39;];</p><p>JSON.stringify(obj, selectedProperties) // &quot;{&quot;prop1&quot;:&quot;value1&quot;,&quot;prop2&quot;:&quot;value2&quot;}&quot;</p><p>这个类似白名单的数组，只对对象的属性有效,包括嵌套的对象，对数组无效。 JSON.stringify([&#39;a&#39;, &#39;b&#39;], [&#39;0&#39;]) // &quot;[&quot;a&quot;,&quot;b&quot;]&quot;</p><p>JSON.stringify({0: &#39;a&#39;, 1: &#39;b&#39;}, [&#39;0&#39;]) // &quot;{&quot;0&quot;:&quot;a&quot;}&quot;</p><p>第二个参数还可以是一个函数，用来更改JSON.stringify()的返回值。 function f(key, value) { if (typeof value === &quot;number&quot;) { value = 2 * value; } return value; }</p><p>JSON.stringify({ a: 1, b: 2 }, f) // &#39;{&quot;a&quot;: 2,&quot;b&quot;: 4}&#39;</p><p>注意，这个处理函数是递归处理所有的键，包括数组。 var obj = {a: {b: 1}};</p><p>function f(key, value) { console.log(&quot;[&quot;+ key +&quot;]:&quot; + value); return value; }</p><p>JSON.stringify(obj, f) // []:[object Object] // [a]:[object Object] // [b]:1 // &#39;{&quot;a&quot;:{&quot;b&quot;:1}}&#39;</p><p>递归处理中，每一次处理的对象，都是前一次返回的值。 var obj = {a: 1};</p><p>function f(key, value) { if (typeof value === &#39;object&#39;) { return {b: 2}; } return value * 2; }</p><p>JSON.stringify(obj, f) // &quot;{&quot;b&quot;: 4}&quot;</p><p>如果处理函数返回undefined或没有返回值，则该属性会被忽略。 function f(key, value) { if (typeof(value) === &quot;string&quot;) { return undefined; } return value; }</p><p>JSON.stringify({ a: &quot;abc&quot;, b: 123 }, f) // &#39;{&quot;b&quot;: 123}&#39;</p><p>space JSON.stringify()还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。 默认返回的是单行字符串，对于大型的 JSON 对象，可读性非常差。第三个参数使得每个属性单独占据一行，并且将每个属性前面添加指定的前缀（不超过10个字符）。 // 默认输出 JSON.stringify({ p1: 1, p2: 2 }) // &quot;{ &quot;p1&quot;: 1, &quot;p2&quot;: 2 }&quot;</p><p>// 分行输出 JSON.stringify({ p1: 1, p2: 2 }, null, &#39;\\t&#39;) // { // &quot;p1&quot;: 1, // &quot;p2&quot;: 2 // }</p><p>// 保留空格 JSON.stringify({ p1: 1, p2: 2 }, null, 2); /* &quot;{ &quot;p1&quot;: 1, &quot;p2&quot;: 2 }&quot; */</p><p>参数对象的 toJSON() 方法 如果参数对象有自定义的toJSON()方法，那么JSON.stringify()会使用这个方法的返回值作为参数，而忽略原对象的其他属性。 下面是一个普通的对象。 var user = { firstName: &#39;三&#39;, lastName: &#39;张&#39;,</p><p>get fullName(){ return this.lastName + this.firstName; } };</p><p>JSON.stringify(user) // &quot;{&quot;firstName&quot;:&quot;三&quot;,&quot;lastName&quot;:&quot;张&quot;,&quot;fullName&quot;:&quot;张三&quot;}&quot;</p><p>现在，为这个对象加上toJSON()方法。 var user = { firstName: &#39;三&#39;, lastName: &#39;张&#39;,</p><p>get fullName(){ return this.lastName + this.firstName; },</p><p>toJSON: function () { return { name: this.lastName + this.firstName }; } };</p><p>JSON.stringify(user) // &quot;{&quot;name&quot;:&quot;张三&quot;}&quot;</p><p>Date对象就有一个自己的toJSON()方法。 var date = new Date(&#39;2015-01-01&#39;); date.toJSON() // &quot;2015-01-01T00:00:00.000Z&quot; JSON.stringify(date) // &quot;&quot;2015-01-01T00:00:00.000Z&quot;&quot;</p><p>toJSON()方法的一个应用是，将正则对象自动转为字符串。因为JSON.stringify()默认不能转换正则对象，但是设置了toJSON()方法以后，就可以转换正则对象了。 var obj = { reg: /foo/ };</p><p>// 不设置 toJSON 方法时 JSON.stringify(obj) // &quot;{&quot;reg&quot;:{}}&quot;</p><p>// 设置 toJSON 方法时 RegExp.prototype.toJSON = RegExp.prototype.toString; JSON.stringify(/foo/) // &quot;&quot;/foo/&quot;&quot;</p><p>JSON.parse() JSON.parse()方法用于将 JSON 字符串转换成对应的值。 JSON.parse(&#39;{}&#39;) // {} JSON.parse(&#39;true&#39;) // true JSON.parse(&#39;&quot;foo&quot;&#39;) // &quot;foo&quot; JSON.parse(&#39;[1, 5, &quot;false&quot;]&#39;) // [1, 5, &quot;false&quot;] JSON.parse(&#39;null&#39;) // null</p><p>var o = JSON.parse(&#39;{&quot;name&quot;: &quot;张三&quot;}&#39;); o.name // 张三</p><p>如果传入的字符串不是有效的 JSON 格式，JSON.parse()方法将报错。为了处理解析错误，可以将JSON.parse()方法放在try...catch代码块中 try { JSON.parse(&quot;&#39;String&#39;&quot;); // SyntaxError: Unexpected token ILLEGAL } catch(e) { console.log(&#39;parsing error&#39;); }</p><p>reviver JSON.parse()方法可以接受一个处理函数，作为第二个参数，用法与JSON.stringify()方法类似。 function f(key, value) { if (key === &#39;a&#39;) { return value + 10; } return value; }</p><p>JSON.parse(&#39;{&quot;a&quot;: 1, &quot;b&quot;: 2}&#39;, f) // {a: 11, b: 2}</p><p>如果 reviver 返回 undefined，则当前属性会从所属对象中删除，如果返回了其他值，则返回的值会成为当前属性新的属性值</p>',57),r=[p];function a(i,n){return o(),u("div",null,r)}const f=t(q,[["render",a],["__file","json.html.vue"]]);export{f as default};
